[{"path":"/articles/bootstrap.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Bootstrap Analysis with trieff","text":"Bootstrap analysis trieff provides confidence intervals Triage Effectiveness metrics enables assessment statistical stability. vignette demonstrates use bootstrapping effectively interpret results. confidence intervals calculated can visualized using plotting functions described vignette(\"plot_te\"). visualization provides intuitive way understand uncertainty TE estimates. Two bootstrapping methods available trieff: Standard Bootstrap: Traditional approach randomly samples individual cases replacement. Segment Bootstrap: Advanced approach preserves temporal patterns sampling segments continuous queue activity. methods work repeatedly sampling dataset, calculating TE metrics sample, using distribution calculations estimate confidence intervals.","code":""},{"path":"/articles/bootstrap.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Bootstrap Analysis with trieff","text":"Knowledge basic TE calculation (see vignette(\"calc_wte\")) Simulated theoretical wait times (see vignette(\"sim_te\"))","code":""},{"path":"/articles/bootstrap.html","id":"why-bootstrap","dir":"Articles","previous_headings":"","what":"Why Bootstrap?","title":"Bootstrap Analysis with trieff","text":"Bootstrapping helps us understand: reliability TE metrics stability estimates impact rare events outliers reliable bootstrap analysis, recommend using least 3 months ED data, though guideline based preliminary analysis may need adjustment specific context.","code":""},{"path":"/articles/bootstrap.html","id":"basic-bootstrap-usage","dir":"Articles","previous_headings":"","what":"Basic Bootstrap Usage","title":"Bootstrap Analysis with trieff","text":"Let’s start basic example using default bootstrap parameters. ’ll use overall_only=TRUE keep output focused: output now includes confidence intervals TE metric, showing uncertainty estimates.","code":"# Calculate TE with bootstrap te_results <- calc_wte(data,                       bootstrap = TRUE,                       overall_only = TRUE) #> [1] \"Starting bootstrap iterations 2025-04-21 14:44:39.144801\" #> [1] \"Bootstrap iterations done 2025-04-21 14:44:58.347394\"  # View results print(te_results) #>  #> Triage Effectiveness Analysis Results #> =================================== #>  #> Results for Overall  #> -------------------  #> Total patients: 124311 (4.4% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 73.7% #>   Specificity: 65.9% #>  #> Triage Effectiveness Metrics: #>   OTE: 29.9% #>   TTE: 52.8% #>   OTG: -23.0% #>  #> Confidence Intervals (95%): #>   OTE:  29.9% (26.8% to 32.9%)  #>   TTE:  52.8% (49.7% to 55.7%)  #>   OTG:  -23.0%  #>  #> Computation Information #> ===================== #> Method: Bootstrap calculation (waiting-time-based) #> Number of iterations: 2000 #> Sample percentage: 100% #> Distribution span: 95% #> Calculation time: 2025-04-21 14:44:58.364805"},{"path":"/articles/bootstrap.html","id":"advanced-bootstrap-configuration","dir":"Articles","previous_headings":"","what":"Advanced Bootstrap Configuration","title":"Bootstrap Analysis with trieff","text":"bootstrap process can customized using several parameters: Key parameters: sample_percentage: Controls resample size (default = 1) n_iterations: Number bootstrap iterations (default = 2000) distribution_span: Width confidence intervals (default = 0.95)","code":"# Custom bootstrap settings te_custom <- calc_wte(data,                      bootstrap = TRUE,                      overall_only = TRUE,                      seed = 123, # use seed to make your results reproducible                      bootstrap_params = list(                        sample_percentage = 0.8,  # Use 80% of data per iteration                        n_iterations = 1000,      # decrease iterations                        distribution_span = 0.99  # Wider confidence intervals                      )) #> [1] \"Starting bootstrap iterations 2025-04-21 14:44:58.791145\" #> [1] \"Bootstrap iterations done 2025-04-21 14:45:09.482014\"  print(te_custom) #>  #> Triage Effectiveness Analysis Results #> =================================== #>  #> Results for Overall  #> -------------------  #> Total patients: 124311 (4.4% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 73.7% #>   Specificity: 65.9% #>  #> Triage Effectiveness Metrics: #>   OTE: 29.9% #>   TTE: 52.8% #>   OTG: -23.0% #>  #> Confidence Intervals (95%): #>   OTE:  29.9% (25.2% to 34.6%)  #>   TTE:  52.8% (48.0% to 57.0%)  #>   OTG:  -23.0%  #>  #> Computation Information #> ===================== #> Method: Bootstrap calculation (waiting-time-based) #> Number of iterations: 1000 #> Sample percentage: 80% #> Distribution span: 99% #> Calculation time: 2025-04-21 14:45:09.493547"},{"path":"/articles/bootstrap.html","id":"standard-vs--segment-bootstrap","dir":"Articles","previous_headings":"","what":"Standard vs. Segment Bootstrap","title":"Bootstrap Analysis with trieff","text":"trieff package offers two different bootstrapping methods:","code":""},{"path":"/articles/bootstrap.html","id":"standard-bootstrap","dir":"Articles","previous_headings":"Standard vs. Segment Bootstrap","what":"Standard Bootstrap","title":"Bootstrap Analysis with trieff","text":"standard bootstrap method (bootstrap = \"standard\" simply bootstrap = TRUE) randomly samples individual patient cases replacement. traditional bootstrap approach.","code":"# Standard bootstrap standard_bootstrap <- calc_wte(data,                              bootstrap = \"standard\") #> [1] \"Starting bootstrap iterations 2025-04-21 14:45:09.885378\" #> [1] \"Bootstrap iterations done 2025-04-21 14:45:29.058234\"  plot_te(standard_bootstrap)"},{"path":"/articles/bootstrap.html","id":"segment-bootstrap","dir":"Articles","previous_headings":"Standard vs. Segment Bootstrap","what":"Segment Bootstrap","title":"Bootstrap Analysis with trieff","text":"segment bootstrap method (bootstrap = \"segment\") preserves temporal patterns sampling segments continuous queue activity. approach maintains dependency structure patients ED time period.","code":"# Segment bootstrap segment_bootstrap <- calc_wte(data,                             bootstrap = \"segment\") #> [1] \"Using existing segments for bootstrap 2025-04-21 14:45:29.588823\" #> [1] \"Starting segment bootstrap with 9784 unit-segment pairs, 9784 samples per iteration, 2000 iterations 2025-04-21 14:45:29.590289\" #> [1] \"Segment bootstrap iterations done 2025-04-21 14:45:41.165363\"  plot_te(segment_bootstrap)"},{"path":"/articles/bootstrap.html","id":"comparing-bootstrap-methods","dir":"Articles","previous_headings":"","what":"Comparing Bootstrap Methods","title":"Bootstrap Analysis with trieff","text":"theoretical understanding suggests segment bootstrapping preferred emergency department data, empirical testing shown methods typically produce equivalent results practice comparable confidence intervals amd neither consistently producing wider narrower intervals . Despite theoretical differences handle data dependencies, practical outputs terms running means confidence interval convergence remarkably similar. methods maintained package support methodological research allow users validate results across different bootstrapping approaches, practical applications, standard bootstrap provides efficient reliable option.","code":"# Function to extract confidence intervals get_ci_width <- function(result) {   ci_width <- result$results %>%     mutate(ote_ci_width = boot_ote_var_upper - boot_ote_var_lower) %>%     select(unit, ote_ci_width)   return(ci_width) }  # Compare CI widths standard_ci <- get_ci_width(standard_bootstrap) segment_ci <- get_ci_width(segment_bootstrap)  # Display results comparison <- standard_ci %>%   left_join(segment_ci, by = \"unit\", suffix = c(\"_standard\", \"_segment\")) %>%   mutate(difference = ote_ci_width_segment - ote_ci_width_standard)  print(comparison) #> # A tibble: 4 × 4 #>   unit        ote_ci_width_standard ote_ci_width_segment difference #>   <chr>                       <dbl>                <dbl>      <dbl> #> 1 overall                    0.0609               0.0689   0.00801  #> 2 medical                    0.0659               0.0799   0.0140   #> 3 orthopedics                0.314                0.314   -0.000303 #> 4 surgical                   0.128                0.132    0.00400"},{"path":"/articles/bootstrap.html","id":"how-segment-bootstrap-works","dir":"Articles","previous_headings":"","what":"How Segment Bootstrap Works","title":"Bootstrap Analysis with trieff","text":"segment bootstrap can described custom block bootstrap operates : Identifying segments continuous queue activity (periods queue starts 0 ends 0) Sampling segments replacement Calculating TE metrics resampled dataset approach preserves temporal structure patient flow, including: Arrival patterns Concurrent cases Crowding effects Priority interrelationships block bootstrapping reduces effect temporal effects, argue approach remove effect altogether. However, keep mind seem affect results, stated .","code":""},{"path":"/articles/bootstrap.html","id":"convergence-analysis","dir":"Articles","previous_headings":"","what":"Convergence Analysis","title":"Bootstrap Analysis with trieff","text":"Convergence analysis helps verify bootstrap estimates stable. check_convergence=TRUE (standard), calc_wte generates three types diagnostic plots: Shows average TE estimate evolves iterations stabilize roughly horizontal line Large fluctuations end suggest need iterations Shows confidence interval width changes iterations decrease stabilize Continued narrowing suggests potential precise estimates Shows standard error estimates changes decrease stabilize Helps assess estimate precision Let’s examine convergence analysis:  Interpreting convergence plots: - Look stabilization three metrics - Check late iterations show systematic changes - Verify CI width reached reasonable stability convergence looks poor, consider: - Increasing n_iterations - Checking data quality issues - Verifying sufficient sample size","code":"# Calculate TE with convergence checking te_convergence <- calc_wte(data,                          bootstrap = TRUE,                          overall_only = TRUE,                          check_convergence = TRUE) #> [1] \"Starting bootstrap iterations 2025-04-21 14:45:42.024575\" #> [1] \"Bootstrap iterations done 2025-04-21 14:46:01.353966\"  # View convergence plots print(te_convergence$convergence) #>  #> Convergence Analysis Summary #> ========================= #> Metrics analyzed: ote_te, tte_te, btte_te"},{"path":"/articles/bootstrap.html","id":"comparing-confidence-intervals-for-rte","dir":"Articles","previous_headings":"","what":"Comparing Confidence Intervals for RTE","title":"Bootstrap Analysis with trieff","text":"RTE CAN use direct calculation show confidence intervals, bootstrapping offers best balance validity usable results experience. Let’s examine different approaches:","code":"# Calculate RTE with bootstrap rte_bootstrap <- calc_rte(data, bootstrap = TRUE, overall_only = TRUE) #> [1] \"Starting RTE bootstrap with 2000 iterations, sample size 124311 at 2025-04-21 14:46:07.359614\" #> [1] \"RTE bootstrap completed at 2025-04-21 14:46:21.532072\"  # Calculate RTE with direct calculation (no bootstrap) rte_direct <- calc_rte(data, bootstrap = FALSE, overall_only = TRUE)  # Create plots with different CI approaches plot_bootstrap <- plot_te(rte_bootstrap,                           title = \"RTE with Bootstrap CI\",                          min_x = -2.6)  plot_parametric <- plot_te(rte_direct,                            ci_vars_override = \"parametric\",                           title = \"RTE with Parametric CI\",                           min_x = -2.6)  plot_nonparametric <- plot_te(rte_direct,                               ci_vars_override = \"nonparametric\",                              title = \"RTE with Non-parametric CI\")  # Display plots patchwork::wrap_plots(plot_bootstrap, plot_parametric, plot_nonparametric, ncol = 1)"},{"path":"/articles/bootstrap.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Bootstrap Analysis with trieff","text":"Bootstrap analysis trieff provides valuable insights reliability TE metrics. Key points: Use bootstrapping get confidence intervals TE metrics Standard bootstrap independent cases Segment bootstrap preserving temporal patterns Verify convergence using diagnostic plots Adjust parameters based dataset size precision needs Consider computational resources large datasets Remember bootstrapping provides valuable statistical information, combined domain knowledge practical considerations evaluating triage system performance.","code":""},{"path":"/articles/calc_te.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Calculating Triage Effectiveness","text":"vignette demonstrates calculate Triage Effectiveness (TE) using calc_te function trieff package. ’ll use included sem_malmo_synth dataset, contains synthetic emergency department visit data based Malmö Hospital statistics. recommended run simulation generate Theoretical TE values calculating TE, especially ’re interested analyzing theoretical wait times (see Simulation vignette details, vignette(\"sim_te\")).","code":""},{"path":"/articles/calc_te.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Calculating Triage Effectiveness","text":"Initialized data (see vignette(\"getting_started\")) Simulated theoretical wait times (see vignette(\"sim_te\")) - strict prerequisite.","code":""},{"path":"/articles/calc_te.html","id":"basic-usage","dir":"Articles","previous_headings":"","what":"Basic Usage","title":"Calculating Triage Effectiveness","text":"Let’s start basic example calculating TE. Note default, results calculated medical unit separately since typically operate independent queues:","code":"# First initialize the data data <- init(sem_malmo_synth)  # Run simulation to get theoretical wait times data <- sim_te(data) #> [1] \"Creating segments out of dataframe 2025-03-07 13:16:01.275822\" #> [1] \"Filtered to 1486 segments with LOSET cases\" #> [1] \"Total LOSET cases: 5491\" #> [1] \"Starting multisession with 1 cores. 2025-03-07 13:16:01.411063\" #> [1] \"Simulations are done! 2025-03-07 13:16:06.259401\"  # Calculate TE metrics te_results <- calc_te(data)  # Print results using the custom print method print(te_results) #>  #> Triage Effectiveness Analysis Results #> =================================== #>  #> Results for Overall  #> -------------------  #> Total patients: 124311 (4.4% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 73.7% #>   Specificity: 65.9% #>  #> Triage Effectiveness Metrics: #>   OTE: 29.9% #>   TTE: 52.8% #>   OTG: -23.0% #>  #> Results for unit: medical  #> -------------------------  #> Total patients: 63690 (6.4% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 78.1% #>   Specificity: 61.5% #>  #> Triage Effectiveness Metrics: #>   OTE: 35.0% #>   TTE: 58.7% #>   OTG: -23.7% #>  #> Results for unit: orthopedics  #> -----------------------------  #> Total patients: 25976 (1.2% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 54.8% #>   Specificity: 87.2% #>  #> Triage Effectiveness Metrics: #>   OTE: -14.0% #>   TTE: 29.7% #>   OTG: -43.7% #>  #> Results for unit: surgical  #> --------------------------  #> Total patients: 34645 (3.1% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 62.0% #>   Specificity: 76.6% #>  #> Triage Effectiveness Metrics: #>   OTE: 22.6% #>   TTE: 36.9% #>   OTG: -14.3% #>  #> Computation Information #> ===================== #> Method: Direct calculation #> Calculation time: 2025-03-07 13:16:06.546317"},{"path":"/articles/calc_te.html","id":"overall-results-only","dir":"Articles","previous_headings":"","what":"Overall Results Only","title":"Calculating Triage Effectiveness","text":"working just basic unit division, getting unit-level overall results manageable. However, ’ll see later subgroup analysis, output can become quite extensive. overall_only parameter can help manage - let’s introduce :","code":"# Calculate overall TE metrics te_overall <- calc_te(data, overall_only = TRUE)  # Print results print(te_overall) #>  #> Triage Effectiveness Analysis Results #> =================================== #>  #> Results for Overall  #> -------------------  #> Total patients: 124311 (4.4% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 73.7% #>   Specificity: 65.9% #>  #> Triage Effectiveness Metrics: #>   OTE: 29.9% #>   TTE: 52.8% #>   OTG: -23.0% #>  #> Computation Information #> ===================== #> Method: Direct calculation #> Calculation time: 2025-03-07 13:16:06.594306"},{"path":"/articles/calc_te.html","id":"subgroup-analysis","dir":"Articles","previous_headings":"","what":"Subgroup Analysis","title":"Calculating Triage Effectiveness","text":"can analyze specific subgroups, age groups. Notice output becomes quite extensive results combination unit age group: clearer overview working subgroups, can use overall_only focus main patterns:","code":"# Define age groups data <- data %>%   mutate(age_group = cut(age_at_arrival,                          breaks = c(0, 59, 79, Inf),                         labels = c(\"18-59\", \"60-79\", \"80+\")))  # Analyze by age group te_age <- calc_te(data, var1 = \"age_group\")  # Print results print(te_age) #>  #> Triage Effectiveness Analysis Results #> =================================== #>  #> Results for Overall, 18-59  #> --------------------------  #> Total patients: 65531 (2.3% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 72.2% #>   Specificity: 71.7% #>  #> Triage Effectiveness Metrics: #>   OTE: 35.7% #>   TTE: 49.8% #>   OTG: -14.0% #>  #> Results for Overall, 60-79  #> --------------------------  #> Total patients: 36520 (6.2% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 74.3% #>   Specificity: 62.4% #>  #> Triage Effectiveness Metrics: #>   OTE: 30.3% #>   TTE: 54.0% #>   OTG: -23.7% #>  #> Results for Overall, 80+  #> ------------------------  #> Total patients: 22260 (7.7% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 74.1% #>   Specificity: 58.9% #>  #> Triage Effectiveness Metrics: #>   OTE: 29.2% #>   TTE: 56.8% #>   OTG: -27.6% #>  #> Results for unit: medical, 18-59  #> --------------------------------  #> Total patients: 28583 (3.3% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 80.1% #>   Specificity: 65.7% #>  #> Triage Effectiveness Metrics: #>   OTE: 37.9% #>   TTE: 57.4% #>   OTG: -19.4% #>  #> Results for unit: medical, 60-79  #> --------------------------------  #> Total patients: 21468 (8.4% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 78.5% #>   Specificity: 58.6% #>  #> Triage Effectiveness Metrics: #>   OTE: 37.0% #>   TTE: 59.8% #>   OTG: -22.8% #>  #> Results for unit: medical, 80+  #> ------------------------------  #> Total patients: 13639 (10.0% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 76.2% #>   Specificity: 56.6% #>  #> Triage Effectiveness Metrics: #>   OTE: 34.2% #>   TTE: 60.4% #>   OTG: -26.2% #>  #> Results for unit: orthopedics, 18-59  #> ------------------------------------  #> Total patients: 16513 (0.7% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 42.3% #>   Specificity: 91.3% #>  #> Triage Effectiveness Metrics: #>   OTE: -5.4% #>   TTE: 24.0% #>   OTG: -29.4% #>  #> Results for unit: orthopedics, 60-79  #> ------------------------------------  #> Total patients: 5977 (1.4% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 53.5% #>   Specificity: 83.9% #>  #> Triage Effectiveness Metrics: #>   OTE: -36.0% #>   TTE: 24.1% #>   OTG: -60.1% #>  #> Results for unit: orthopedics, 80+  #> ----------------------------------  #> Total patients: 3486 (2.9% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 69.6% #>   Specificity: 73.0% #>  #> Triage Effectiveness Metrics: #>   OTE: 9.9% #>   TTE: 48.3% #>   OTG: -38.4% #>  #> Results for unit: surgical, 18-59  #> ---------------------------------  #> Total patients: 20435 (2.2% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 63.0% #>   Specificity: 79.5% #>  #> Triage Effectiveness Metrics: #>   OTE: 41.2% #>   TTE: 40.3% #>   OTG: 0.9% #>  #> Results for unit: surgical, 60-79  #> ---------------------------------  #> Total patients: 9075 (4.1% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 58.8% #>   Specificity: 76.0% #>  #> Triage Effectiveness Metrics: #>   OTE: 13.2% #>   TTE: 32.5% #>   OTG: -19.3% #>  #> Results for unit: surgical, 80+  #> -------------------------------  #> Total patients: 5135 (5.1% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 64.6% #>   Specificity: 65.8% #>  #> Triage Effectiveness Metrics: #>   OTE: 10.7% #>   TTE: 41.2% #>   OTG: -30.5% #>  #> Computation Information #> ===================== #> Method: Direct calculation #> Calculation time: 2025-03-07 13:16:06.640689 # Analyze by age group, overall results only te_age_overall <- calc_te(data, var1 = \"age_group\", overall_only = TRUE)  # Print results print(te_age_overall) #>  #> Triage Effectiveness Analysis Results #> =================================== #>  #> Results for Overall, 18-59  #> --------------------------  #> Total patients: 65531 (2.3% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 72.2% #>   Specificity: 71.7% #>  #> Triage Effectiveness Metrics: #>   OTE: 35.7% #>   TTE: 49.8% #>   OTG: -14.0% #>  #> Results for Overall, 60-79  #> --------------------------  #> Total patients: 36520 (6.2% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 74.3% #>   Specificity: 62.4% #>  #> Triage Effectiveness Metrics: #>   OTE: 30.3% #>   TTE: 54.0% #>   OTG: -23.7% #>  #> Results for Overall, 80+  #> ------------------------  #> Total patients: 22260 (7.7% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 74.1% #>   Specificity: 58.9% #>  #> Triage Effectiveness Metrics: #>   OTE: 29.2% #>   TTE: 56.8% #>   OTG: -27.6% #>  #> Computation Information #> ===================== #> Method: Direct calculation #> Calculation time: 2025-03-07 13:16:06.702634"},{"path":"/articles/calc_te.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Calculating Triage Effectiveness","text":"vignette demonstrated main features calc_te function: Basic TE calculation unit Overall TE calculation Subgroup analysis detailed overall results advanced topics bootstrap analysis convergence checking, please see Bootstrap (vignette(\"bootstrap\")) vignette. visualizing results, see Plotting vignette (vignette(\"plot_te\")). details specific parameters advanced usage, refer function documentation (?calc_te) instructions bootstrapping (?bootstrap).","code":""},{"path":"/articles/calc_wte_rte.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"trieff package offers two complementary approaches calculating Triage Effectiveness (TE): Waiting Time-based TE (WTE): Measures well triage reduces actual waiting time time-critical patients. Rank-based TE (RTE): Evaluates effectively triage improves queue positions time-critical patients. vignette demonstrates use methods, compares results, explains use approach.","code":""},{"path":"/articles/calc_wte_rte.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"Initialized data (see vignette(\"getting_started\")) Simulated theoretical wait times (see vignette(\"sim_te\")), required theoretical TE interest.","code":""},{"path":"/articles/calc_wte_rte.html","id":"basic-usage","dir":"Articles","previous_headings":"","what":"Basic Usage","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"Let’s start initializing data running simulation get theoretical wait times:","code":"# Initialize the data data <- init(sem_malmo_synth)  # Run simulation to get theoretical wait times data <- sim_te(data) #> [1] \"Filtered to 1486 segments with LOSET cases\" #> [1] \"Total LOSET cases: 5491\" #> [1] \"Starting multisession with 1 cores. 2025-04-21 14:46:33.546217\" #> [1] \"Simulations are done! 2025-04-21 14:46:38.409975\""},{"path":"/articles/calc_wte_rte.html","id":"waiting-time-based-te-wte","dir":"Articles","previous_headings":"Basic Usage","what":"Waiting Time-based TE (WTE)","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"First, let’s calculate WTE metrics:","code":"# Calculate WTE metrics wte_results <- calc_wte(data, overall_only = TRUE)  # Print results print(wte_results) #>  #> Triage Effectiveness Analysis Results #> =================================== #>  #> Results for Overall  #> -------------------  #> Total patients: 124311 (4.4% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 73.7% #>   Specificity: 65.9% #>  #> Triage Effectiveness Metrics: #>   OTE: 29.9% #>   TTE: 52.8% #>   OTG: -23.0% #>  #> Computation Information #> ===================== #> Method: Direct calculation (waiting-time-based) #> Calculation time: 2025-04-21 14:46:38.756794"},{"path":"/articles/calc_wte_rte.html","id":"rank-based-te-rte","dir":"Articles","previous_headings":"Basic Usage","what":"Rank-based TE (RTE)","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"Now, let’s calculate RTE metrics using data: Note using argument ‘overall_only = TRUE’ examples . returns overall TE value ED. Trieff calculates based units represents separate queues. example ED separate queues medical surgical patients.","code":"# Calculate RTE metrics rte_results <- calc_rte(data, overall_only = TRUE)  # Print results print(rte_results) #>  #> Triage Effectiveness Analysis Results #> =================================== #>  #> Results for Overall  #> -------------------  #> Total patients: 124311 (4.4% LOSET positive, 5218 valid for RTE) #>  #> Classification Metrics: #>   Sensitivity: 73.7% #>   Specificity: 71.3% #>  #> Rank-based Triage Effectiveness Metrics: #>   OTE: 31.5% #>   TTE: 59.3% #>   OTG: -27.8% #>  #> Confidence Intervals (95%): #>   OTE:  31.5% (-260.0% to 100.0%)  #>   TTE:  59.3% (-138.9% to 100.0%)  #>   OTG:  -27.8%  #>  #> Computation Information #> ===================== #> Method: Rank-based triage effectiveness calculation #> Calculation time: 2025-04-21 14:46:43.936768"},{"path":"/articles/calc_wte_rte.html","id":"comparing-the-results","dir":"Articles","previous_headings":"","what":"Comparing the Results","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"Let’s create visual comparison two methods: Note overriding confidence intervals show argument ci_vars_override = “none”. reason can found print statement . calc_rte recommend confidence interval based Shapiro test. Since queue position generally normally distributed recommend “non_parametric” produces wide confidence intervals. alternative introduced bellow bootstrapping explored vignette(\"bootstrap\")","code":"# Create plots for comparison wte_plot <- plot_te(wte_results, title = \"Waiting Time-based TE (WTE)\") rte_plot <- plot_te(rte_results, title = \"Rank-based TE (RTE)\", ci_vars_override = \"none\")  # Display plots one below the other using patchwork patchwork::wrap_plots(wte_plot, rte_plot, ncol = 1)"},{"path":"/articles/calc_wte_rte.html","id":"subgroup-analysis","dir":"Articles","previous_headings":"","what":"Subgroup Analysis","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"methods support subgroup analysis. Let’s compare using age groups:","code":"# Create age groups data <- data %>%   mutate(age_group = cut(age_at_arrival,                          breaks = c(0, 59, 79, Inf),                         labels = c(\"18-59\", \"60-79\", \"80+\")))  # Calculate WTE and RTE by age group wte_age <- calc_wte(data, var1 = \"age_group\", overall_only = TRUE) rte_age <- calc_rte(data, var1 = \"age_group\", overall_only = TRUE)  # Create comparison plots wte_age_plot <- plot_te(wte_age, title = \"WTE by Age Group\") rte_age_plot <- plot_te(rte_age, title = \"RTE by Age Group\", ci_vars_override = \"none\")  # Display plots patchwork::wrap_plots(wte_age_plot, rte_age_plot, ncol = 1)"},{"path":"/articles/calc_wte_rte.html","id":"bootstrap-analysis","dir":"Articles","previous_headings":"","what":"Bootstrap Analysis","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"methods support bootstrap confidence interval generation:  functions bootstraps final, calculated value.","code":"# Calculate with bootstrap wte_bootstrap <- calc_wte(data,                           bootstrap = TRUE,                          overall_only = TRUE) #> [1] \"Starting bootstrap iterations 2025-04-21 14:46:50.167449\" #> [1] \"Bootstrap iterations done 2025-04-21 14:47:09.396764\"  rte_bootstrap <- calc_rte(data,                          bootstrap = TRUE,                          overall_only = TRUE) #> [1] \"Starting RTE bootstrap with 2000 iterations, sample size 124311 at 2025-04-21 14:47:15.039847\" #> [1] \"RTE bootstrap completed at 2025-04-21 14:47:28.782273\"  # Create plots with confidence intervals wte_boot_plot <- plot_te(wte_bootstrap, title = \"WTE with Bootstrap CI\") rte_boot_plot <- plot_te(rte_bootstrap, title = \"RTE with Bootstrap CI\")  # Display plots patchwork::wrap_plots(wte_boot_plot, rte_boot_plot, ncol = 1)"},{"path":"/articles/calc_wte_rte.html","id":"understanding-te-calculation-methods","dir":"Articles","previous_headings":"","what":"Understanding TE Calculation Methods","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"WTE RTE aim measure effectively triage system prioritizes time-critical patients, using different approaches. section details internal calculation mechanisms method.","code":""},{"path":"/articles/calc_wte_rte.html","id":"waiting-time-based-te-wte-calculation","dir":"Articles","previous_headings":"Understanding TE Calculation Methods","what":"Waiting Time-based TE (WTE) Calculation","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"WTE measures well triage reduces waiting times time-critical patients relative overall average. formula conceptually straightforward: creates scale : WTE = 100%: Time-critical patients 0 wait time WTE = 0%: Time-critical patients wait long average patient (equivalent triage) WTE < 0%: Time-critical patients wait longer average (worse triage) calculation uses two reference points: Mean waiting time patients: Represents expected waiting time first-come, first-served system Zero waiting time: Represents theoretical minimum achievable perfect prioritization can demonstrate calculation simple example: conceptually simple, WTE can affected system throughput, capacity constraints, factors beyond triage decisions . RTE offers complementary perspective.","code":"# The formula for WTE WTE = 1 - (mean waiting time for time-critical patients / mean waiting time for all patients) # Create example data example_wait_times <- data.frame(   patient_id = 1:10,   wait_time = c(45, 60, 30, 90, 15, 75, 60, 45, 30, 120),  # minutes   loset = c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE) )  # Calculate TE mean_all <- mean(example_wait_times$wait_time) mean_loset <- mean(example_wait_times$wait_time[example_wait_times$loset]) wte <- 1 - (mean_loset / mean_all)  # Display results cat(\"Mean wait time for all patients:\", mean_all, \"minutes\\n\") #> Mean wait time for all patients: 57 minutes cat(\"Mean wait time for LOSET patients:\", mean_loset, \"minutes\\n\") #> Mean wait time for LOSET patients: 33.75 minutes cat(\"Waiting Time-based TE:\", round(wte * 100, 1), \"%\\n\") #> Waiting Time-based TE: 40.8 %"},{"path":"/articles/calc_wte_rte.html","id":"rank-based-te-rte-calculation","dir":"Articles","previous_headings":"Understanding TE Calculation Methods","what":"Rank-based TE (RTE) Calculation","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"RTE focuses queue positions rather actual waiting times. measures effectively triage moves time-critical patients forward queue, relative first-come, first-served system. calculation complex involves several key variables: L (Queue Length): number patients queue given patient arrives, including patient. represents position patient first-come, first-served system. p (Position): patient’s actual position resolution sequence, counting arrival time. position 1 means patient first resolved among patients queue, including arrived , next resolve event. n_tc (Time-critical Count): number time-critical patients concurrent window last resolution patient’s arrival first resolution , including patient .","code":""},{"path":"/articles/calc_wte_rte.html","id":"rte-calculation-logic","dir":"Articles","previous_headings":"Understanding TE Calculation Methods > Rank-based TE (RTE) Calculation","what":"RTE Calculation Logic","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"RTE calculation first determines method use based relationship L, p, n_tc, applies appropriate formula: Let’s break different scenarios: patient resolved within first n_tc positions n_tc ≥ L, ambiguous case (explained “Ambiguity Handling” ) Otherwise, RTE = 1 (perfect score) patient resolved first n_tc positions within L positions RTE = (L - p) / (L - n_tc) patient resolved L positions (worse first-come, first-served) RTE = (L - p) / L (negative)","code":"# Function to determine which RTE method to use RTE_method <- function(L, p, n_tc, ambiguity_perfect = TRUE) {   # Perfect triage: patient is seen within n_tc positions   if (p <= n_tc) {     if (n_tc >= L & ambiguity_perfect) {       return(\"perfect\")     } else if(n_tc >= L & !ambiguity_perfect) {       return(\"zero\")     } else {       return(\"perfect\")     }   }   # Positive triage: patient is seen after n_tc but within or at L   else if (p <= L) {     return(\"positive\")   }   # Negative triage: patient is seen after L   else {     return(\"negative\")   } }  # Function to calculate RTE based on the determined method RTE_calculate <- function(L, p, n_tc, method) {   switch(method,          \"perfect\" = 1,          \"positive\" = return((L - p) / (L - n_tc)),          \"negative\" = (L - p) / L,          \"zero\" = 0,          NA_real_  # Default case   ) }"},{"path":"/articles/calc_wte_rte.html","id":"ambiguity-handling","dir":"Articles","previous_headings":"Understanding TE Calculation Methods > Rank-based TE (RTE) Calculation","what":"Ambiguity Handling","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"ambiguous case occurs n_tc ≥ L, meaning many time-critical patients queue length. situation: position perfect prioritization first come, first serve system. Thus RTE can viewed 100% 0% time. treated invalid default can changed setting variable ambiguity_invalid = FALSE, case ambiguity_perfect parameter becomes interesting: TRUE (default), cases scored “perfect” (RTE = 1) FALSE, cases scored “zero” (RTE = 0)","code":""},{"path":"/articles/calc_wte_rte.html","id":"validity-considerations","dir":"Articles","previous_headings":"Understanding TE Calculation Methods > Rank-based TE (RTE) Calculation","what":"Validity Considerations","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"queue scenarios allow meaningful RTE calculation. time-critical patient’s RTE calculation considered valid : ’s least one non-time-critical patient ED within relevant time window, L ≠ n_tc (queue composition allows meaningful prioritization) Cases patients queue time-critical make prioritization meaningless, ordering result average waiting time queue position time-critical patients.","code":""},{"path":"/articles/calc_wte_rte.html","id":"example-rte-calculations","dir":"Articles","previous_headings":"Understanding TE Calculation Methods > Rank-based TE (RTE) Calculation","what":"Example RTE Calculations","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"Let’s illustrate examples: Let’s analyze example: Standard Positive: time-critical patient (n_tc = 1) arrives 5 others already queue (L = 6) resolved third (p = 3). shows good perfect prioritization. Perfect Triage: time-critical patient among 2 time-critical patients (n_tc = 2) queue 4 (L = 4) gets resolved first (p = 1). optimal prioritization. Negative Triage: time-critical patient (n_tc = 1) queue 3 (L = 3) isn’t resolved position 5 (p = 5), meaning patients arrived resolved first. shows poor prioritization. Ambiguous Case: time-critical patients (n_tc = 4) queue length (L = 3), making meaningful prioritization impossible. default setting treats invalid.","code":"# Example scenarios examples <- data.frame(   scenario = c(\"Standard positive\", \"Perfect triage\", \"Negative triage\", \"Ambiguous case\"),   L = c(6, 4, 3, 3),   p = c(3, 1, 5, 1),   n_tc = c(1, 2, 1, 4) )  # Calculate RTE for each scenario examples$method <- mapply(RTE_method, examples$L, examples$p, examples$n_tc) examples$rte <- mapply(   function(L, p, n_tc, method) RTE_calculate(L, p, n_tc, method),   examples$L, examples$p, examples$n_tc, examples$method )  # Display results examples$rte_percent <- paste0(round(examples$rte * 100, 1), \"%\") print(examples[, c(\"scenario\", \"L\", \"p\", \"n_tc\", \"method\", \"rte_percent\")]) #>            scenario L p n_tc   method rte_percent #> 1 Standard positive 6 3    1 positive         60% #> 2    Perfect triage 4 1    2  perfect        100% #> 3   Negative triage 3 5    1 negative      -66.7% #> 4    Ambiguous case 3 1    4  perfect        100%"},{"path":"/articles/calc_wte_rte.html","id":"which-measure-is-more-correct","dir":"Articles","previous_headings":"Understanding TE Calculation Methods","what":"Which Measure is More “Correct”?","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"Neither WTE RTE inherently “correct” - measure different aspects triage performance: WTE directly reflects real-world impact patient waiting times, ultimately matters patients’ experience outcomes. However, can influenced factors beyond triage decisions. RTE isolates quality triage decisions focusing purely queue positioning, independent system throughput. makes useful comparing triage systems across EDs different capacities. within ED comparing performance cases mean waiting time might differs significantly, example comparing night day. practice, RTE typically gives slightly higher values WTE since assume perfect preemptive interventions (.e., zero waiting time ideal). However, perspectives considered valid, analyzing measures provides complete picture triage performance.","code":""},{"path":"/articles/calc_wte_rte.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Waiting Time vs. Rank-based Triage Effectiveness","text":"vignette demonstrated: calculate WTE RTE key differences approaches use method understanding perspectives, can gain complete picture triage performance. detailed information, refer function documentation (?calc_wte ?calc_rte), depth information bootstrapping, see vignette(\"bootstrap\"). learn visualization options, see vignette(\"plot_te\").","code":""},{"path":"/articles/getting_started.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started with trieff","text":"trieff package provides tools analyzing evaluating triage effectiveness, example emergency departments. core, measures well triage systems achieve fundamental purpose: reducing waiting times time-critical patients. package uses two key reference points: waiting time without triage system (first-come, first-served), defined mean waiting time patients. theoretical minimum waiting time achievable perfect triage, defined 0 waiting time. reference points, calculate Triage Effectiveness (TE), creates scale : 0% indicates improvement first-come, first-served 100% indicates perfect prioritization time-critical patients experience waiting Negative values indicate longer waiting times system without triage Triage Effectiveness calculated: 1 - (mean waiting time time critical patients/mean waiting time patients)","code":""},{"path":"/articles/getting_started.html","id":"basic-workflow","dir":"Articles","previous_headings":"","what":"Basic Workflow","title":"Getting Started with trieff","text":"Let’s walk basic workflow using included synthetic dataset sem_malmo_synth, based emergency department visits Malmö Hospital (See ?sem_malmo_synth).","code":""},{"path":"/articles/getting_started.html","id":"initialize-data","dir":"Articles","previous_headings":"Basic Workflow","what":"1. Initialize Data","title":"Getting Started with trieff","text":"First, need initialize data, prepares analysis calculating wait times setting required variables:","code":"# Initialize the data data <- init(sem_malmo_synth)"},{"path":"/articles/getting_started.html","id":"simulate-theoretical-wait-times","dir":"Articles","previous_headings":"Basic Workflow","what":"2. Simulate Theoretical Wait Times","title":"Getting Started with trieff","text":"understand well triage system performs without effect changes priority can happen triage simulate theoretical wait times. shows happen patients seen strictly order assigned priority/arrival time:","code":"# Run simulation for theoretical wait times data <- sim_te(data) #> [1] \"Filtered to 3 segments with LOSET cases\" #> [1] \"Total LOSET cases: 5491\" #> [1] \"Starting multisession with 1 cores. 2025-04-21 14:47:34.095724\" #> [1] \"Simulations are done! 2025-04-21 14:48:36.727472\""},{"path":"/articles/getting_started.html","id":"calculate-triage-effectiveness","dir":"Articles","previous_headings":"Basic Workflow","what":"3. Calculate Triage Effectiveness","title":"Getting Started with trieff","text":"Now can calculate Observed Triage Effectiveness (OTE) Theoretical Triage Effectiveness (TTE): results show us: - OTE: well ED actually performed - TTE: well performed based triage decisions alone - OTG (Observed-Theoretical Gap): difference OTE TTE, indicating impact post-triage processes. Note: TE can calculated using two complementary approaches: Waiting Time-based TE (WTE) measures actual time reduction, Rank-based TE (RTE) focuses queue position improvement.","code":"# Calculate TE metrics te_results <- calc_wte(data, overall_only = TRUE) print(te_results) #>  #> Triage Effectiveness Analysis Results #> =================================== #>  #> Results for Overall  #> -------------------  #> Total patients: 124311 (4.4% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 73.7% #>   Specificity: 65.9% #>  #> Triage Effectiveness Metrics: #>   OTE: 29.9% #>   TTE: 52.8% #>   OTG: -23.0% #>  #> Computation Information #> ===================== #> Method: Direct calculation (waiting-time-based) #> Calculation time: 2025-04-21 14:48:36.794857"},{"path":"/articles/getting_started.html","id":"visualize-results","dir":"Articles","previous_headings":"Basic Workflow","what":"4. Visualize Results","title":"Getting Started with trieff","text":"Finally, can visualize results:","code":"# Create a basic TE plot plot_te(te_results)"},{"path":"/articles/getting_started.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Getting Started with trieff","text":"See individual vignettes component detailed usage, error handling, advanced features: vignette(\"sim_te\") simulation details performance considerations vignette(\"calc_wte_rte\") calculating TE metrics either WTE RTE vignette(\"bootstrap\") statistical validation variance calculation vignette(\"plot_te\") visualization options vignette(\"heatmap\") research theoretical analysis","code":""},{"path":"/articles/getting_started.html","id":"data-requirements","dir":"Articles","previous_headings":"","what":"Data Requirements","title":"Getting Started with trieff","text":"use trieff, data needs: Arrival times - recomend setting time patient gets priority, named “arrival” Times physician contact, named “resolve” Triage priorities, numbers 1 highest Unit assignments (applicable) Time-critical status indicators, trieff package designated “loset”","code":""},{"path":"/articles/getting_started.html","id":"common-issues","dir":"Articles","previous_headings":"","what":"Common Issues","title":"Getting Started with trieff","text":"Missing incorrect column names -> Use init() validate data structure See ?sem_malmo_synth example structure data. detailed information specific functions, see respective vignettes help pages.","code":""},{"path":"/articles/heatmap.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Heatmap Analysis in trieff","text":"heatmap functionality trieff primarily research tool designed explore validate theoretical properties Triage Effectiveness (TE). Unlike features package, heatmap generation computationally intensive typically used understanding fundamental relationships rather day--day analysis. trieff supports Waiting Time-based TE (WTE) Rank-based TE (RTE) methods heatmap generation, offering different perspectives triage system performance. However RTE naturaly normalizes 0% 100% makes results directly comparable across different ED settings sensitivity/specificity combinations.","code":""},{"path":"/articles/heatmap.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Heatmap Analysis in trieff","text":"Understanding TE concepts (vignette(\"getting_started\")) Familiarity simulation (vignette(\"sim_te\")) Understanding WTE RTE differences (vignette(\"calc_wte_rte\")) Computational resources processing","code":""},{"path":"/articles/heatmap.html","id":"relationship-to-simulation","dir":"Articles","previous_headings":"","what":"Relationship to Simulation","title":"Heatmap Analysis in trieff","text":"heatmap analysis builds simulation framework described vignette(\"sim_te\"). However, requires significantly computational resources due repeated simulations across sensitivity/specificity combinations.","code":""},{"path":"/articles/heatmap.html","id":"important-considerations","dir":"Articles","previous_headings":"Relationship to Simulation","what":"Important Considerations","title":"Heatmap Analysis in trieff","text":"Computational Cost: Full heatmap generation typical ED datasets (>100,000 visits) can take several minutes hours depending step size. Intended Use: tool meant researchers validating TE properties comparing results across different ED settings. Limitation: heatmap naturally handle different units recommended simulate one unit per heatmap.","code":""},{"path":"/articles/heatmap.html","id":"understanding-heatmap-results","dir":"Articles","previous_headings":"","what":"Understanding Heatmap Results","title":"Heatmap Analysis in trieff","text":"TE heatmap visualizes different combinations sensitivity specificity affect TE values. key patterns established far : sum sensitivity specificity must exceed 1 positive TE values sum exceeds 1, improving sensitivity yields slightly better gains 1, improving specificity beneficial rules generally hard validate sum close 1, likely due stochastic reasons inflow LOSET patients uneven operational hours mean waiting time also uneven, time critical cases arrives night waiting times longer values sensitivity specificity sum close 1 can diverge 0 WTE, RTE. Let’s compare WTE RTE heatmaps small dataset:  Notice heatmaps reveal similar patterns, RTE heatmap (right) may show consistent scale due natural normalization properties.","code":"# Get a small sample (1 week) of data small_data <- init(sem_malmo_synth[   sem_malmo_synth$arrival >= min(sem_malmo_synth$arrival) &   sem_malmo_synth$arrival <= min(sem_malmo_synth$arrival) + lubridate::days(7), ])  data <- sem_malmo_synth %>%     filter(unit == \"medical\") %>% # Use only one unit per sim     init()  # Generate heatmap data using both calculation methods # WARNING: Even with this small dataset, this may take several minutes wte_heatmap <- data %>%    sim_heat(n_workers = 4, step_size = 10, calc_method = \"wte\") #> [1] \"Processing 527 segments with LOSET cases\" #> [1] \"Starting simulations with 121 combinations 2025-04-21 14:48:40.576104\" #> [1] \"Simulations complete 2025-04-21 14:50:06.508623\" #> [1] \"Calculation method used: wte\"  rte_heatmap <- data %>%    sim_heat(n_workers = 4, step_size = 10, calc_method = \"rte\") #> [1] \"Processing 527 segments with LOSET cases\" #> [1] \"Starting simulations with 121 combinations 2025-04-21 14:50:06.698093\" #> [1] \"Simulations complete 2025-04-21 14:52:21.904291\" #> [1] \"Calculation method used: rte\"  # Create and combine heatmaps wte_plot <- plot_te_heatmap(wte_heatmap, title = \"WTE Heatmap\") rte_plot <- plot_te_heatmap(rte_heatmap, title = \"RTE Heatmap\")  # Display side by side wte_plot | rte_plot"},{"path":"/articles/heatmap.html","id":"normalization-in-heatmaps","dir":"Articles","previous_headings":"","what":"Normalization in Heatmaps","title":"Heatmap Analysis in trieff","text":"Normalization particularly important comparing heatmaps across different EDs datasets. RTE naturally normalized due definition, WTE may benefit explicit normalization facilitate comparison:  Normalization WTE scales values make visually comparable. RTE, normalization less necessary since values already scale naturally runs negative values (worse random) 0 (equivalent random) 1 (perfect prioritization).","code":"# Create normalized WTE heatmap wte_norm_plot <- plot_te_heatmap(wte_heatmap, normalize = TRUE,                               title = \"WTE Heatmap (Normalized)\")  # RTE doesn't typically require normalization rte_norm_plot <- plot_te_heatmap(rte_heatmap,                               title = \"RTE Heatmap (No Normalization Needed)\")  # Display side by side wte_norm_plot | rte_norm_plot"},{"path":"/articles/heatmap.html","id":"alternative-calculations","dir":"Articles","previous_headings":"","what":"Alternative Calculations","title":"Heatmap Analysis in trieff","text":"package includes several alternative TE calculations (cube root, log, median-based) primarily research validation. currently available WTE can accessed using sim_heat_alt():   alternatives help validate patterns observe aren’t artifacts calculation method. Note alternative calculations primarily applicable WTE necessary RTE due already normalized nature.","code":"# Example of alternative calculations with WTE alt_calc <- sim_heat_alt(data, alt_calc = TRUE, step_size = 25) %>%    plot_te_heatmap(show_alt_calc = TRUE) #> [1] \"Starting simulations with 25 combinations 2025-04-21 14:52:22.731448\" #> [1] \"Simulations complete 2025-04-21 14:52:46.359577\" #> [1] \"Calculation method used: rte\"  alt_calc$te_batch # The first possible alternative heat map alt_calc$normalized_te_batch # The second possible alternative heat map alt_calc$all_batch # The third possible alternative heat map #> NULL"},{"path":"/articles/heatmap.html","id":"color-scheme-options","dir":"Articles","previous_headings":"","what":"Color Scheme Options","title":"Heatmap Analysis in trieff","text":"plot_te_heatmap function supports different color schemes color_scheme parameter. particularly useful choosing appropriate visualizations different audiences, including options colorblind-friendly.","code":""},{"path":"/articles/heatmap.html","id":"available-color-schemes","dir":"Articles","previous_headings":"Color Scheme Options","what":"Available Color Schemes","title":"Heatmap Analysis in trieff","text":"color scheme different characteristics: OceanSky (default): Uses medium blue (#3a75c4), light blue, light yellow, gold. Fully colorblind-safe excellent text readability across colors. Provides intuitive “cool--warm” progression works well diverse audiences. BlueOrange: Implements scientifically-designed diverging color palette based ColorBrewer’s “RdBu” (Red-Blue) scale (#2c7bb6, #abd9e9, #fdae61, #d7191c). ThermalSafe: Uses purple, light blue, yellow, orange. Colorblind-safe evokes thermal imaging aesthetics. Provides strong differentiation values maintaining accessibility. Triage: Uses classic triage colors (red, orange, yellow, green) familiar healthcare settings. colorblind-safe immediately recognizable healthcare professionals work triage systems.","code":"# Create a 2x2 grid of heatmaps with different color schemes color_schemes <- c(\"oceansky\", \"blueorange\", \"thermalsafe\", \"triage\")  # Generate plots with each color scheme color_scheme_plots <- list()  for (scheme in color_schemes) {   color_scheme_plots[[scheme]] <- plot_te_heatmap(     rte_heatmap, # Using RTE heatmap for color scheme examples     color_scheme = scheme,     title = paste(toupper(substr(scheme, 1, 1)), substr(scheme, 2, nchar(scheme)), \"Scheme\", sep=\"\")   ) }  # Combine the plots in a grid patchwork::wrap_plots(color_scheme_plots, ncol = 2)"},{"path":"/articles/heatmap.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Heatmap Analysis in trieff","text":"Heatmap analysis trieff powerful research tool understanding TE properties. Key takeaways: WTE RTE calculation methods available heatmap generation RTE offers naturally normalized results, making well-suited comparative analysis WTE may require explicit normalization optimal visualization methods reveal similar fundamental patterns relationship sensitivity, specificity, TE Use calc_method parameter sim_heat() select preferred calculation approach researchers interested detailed heatmap analysis, recommend reviewing methods section TE paper (see vignette(\"original_study\")) ensuring sufficient computational resources beginning analysis. regular TE analysis ED, recommend using main calc_wte() calc_rte() functions demonstrated vignettes.","code":""},{"path":"/articles/original_study.html","id":"original-study","dir":"Articles","previous_headings":"","what":"Original Study","title":"The Triage Effectiveness Framework","text":"page describes original study introduced Triage Effectiveness Framework. [Study details added upon publication]","code":""},{"path":"/articles/original_study.html","id":"contact","dir":"Articles","previous_headings":"","what":"Contact","title":"The Triage Effectiveness Framework","text":"questions framework discuss potential applications: andre.johansson@med.lu.se","code":""},{"path":"/articles/original_study.html","id":"citation","dir":"Articles","previous_headings":"","what":"Citation","title":"The Triage Effectiveness Framework","text":"[Citation information added upon publication]","code":""},{"path":"/articles/plot_te.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Plotting Triage Effectiveness Results","text":"plot_te() function provides flexible visualization Triage Effectiveness results. vignette demonstrates create customize visualizations Waiting Time-based TE (WTE) Rank-based TE (RTE) calculations.","code":""},{"path":"/articles/plot_te.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Plotting Triage Effectiveness Results","text":"Calculated TE metrics using calc_wte() calc_rte() (see vignette(\"calc_wte_rte\")) Optional: Bootstrap results confidence intervals (see vignette(\"bootstrap\"))","code":""},{"path":"/articles/plot_te.html","id":"understanding-te-visualization-methods","dir":"Articles","previous_headings":"","what":"Understanding TE Visualization Methods","title":"Plotting Triage Effectiveness Results","text":"diving examples, ’s important understand two complementary approaches measuring visualizing Triage Effectiveness: Waiting Time-based TE (WTE): Measures well triage reduces actual waiting time time-critical patients. Rank-based TE (RTE): Evaluates effectively triage improves queue positions time-critical patients. approaches strengths different confidence interval calculation methods, demonstrated throughout vignette.","code":""},{"path":"/articles/plot_te.html","id":"basic-plotting","dir":"Articles","previous_headings":"","what":"Basic Plotting","title":"Plotting Triage Effectiveness Results","text":"Let’s start basic plots WTE RTE:  default, plots show Theoretical TE (teal) Observed TE (purple) values. horizontal lines connecting points represent Observed-Theoretical Gap (OTG).","code":"# Calculate WTE metrics wte_results <- calc_wte(data, overall_only = TRUE)  # Calculate RTE metrics  rte_results <- calc_rte(data, overall_only = TRUE)  # Create basic plots wte_plot <- plot_te(wte_results, title = \"Waiting Time-based TE (WTE)\") rte_plot <- plot_te(rte_results, title = \"Rank-based TE (RTE)\", ci_vars_override = \"none\")  # Display plots wte_plot / rte_plot"},{"path":"/articles/plot_te.html","id":"confidence-interval-types","dir":"Articles","previous_headings":"","what":"Confidence Interval Types","title":"Plotting Triage Effectiveness Results","text":"plot_te() function offers several options displaying confidence intervals using ci_vars_override parameter. particularly important working RTE, queue positions often non-normal distributions. available confidence interval types : Parametric: Based normal distribution assumptions (t-distribution) Non-parametric: Based quantiles actual distribution Bootstrap: Derived bootstrap resampling None: confidence intervals displayed Let’s see different CI types affect visualizations:  Note non-parametric confidence intervals often wider parametric ones RTE due non-normal distribution queue positions. analyses, bootstrap confidence intervals provide good balance validity interpretability.","code":"# Calculate RTE with all CI types available rte_boot <- calc_rte(data, bootstrap = TRUE, overall_only = TRUE) #> [1] \"Starting RTE bootstrap with 2000 iterations, sample size 124311 at 2025-04-21 14:53:09.417084\" #> [1] \"RTE bootstrap completed at 2025-04-21 14:53:24.491036\"  # Create plots with different CI types plot1 <- plot_te(rte_boot, ci_vars_override = \"parametric\",                  title = \"RTE with Parametric CI\")  plot2 <- plot_te(rte_boot, ci_vars_override = \"nonparametric\",                  title = \"RTE with Non-parametric CI\")  plot3 <- plot_te(rte_boot, ci_vars_override = \"boot\",                  title = \"RTE with Bootstrap CI\")  plot4 <- plot_te(rte_boot, ci_vars_override = \"none\",                  title = \"RTE with No CI\")  # Display plots (plot1 / plot2) | (plot3 / plot4)"},{"path":"/articles/plot_te.html","id":"automatic-ci-selection","dir":"Articles","previous_headings":"","what":"Automatic CI Selection","title":"Plotting Triage Effectiveness Results","text":"plot_te() function intelligently selects appropriate confidence interval type based priority order: User-specified override via ci_vars_override parameter Bootstrap results (available) RTE: based Shapiro-Wilk test results WTE: bootstrap CIs recommended available None (options available) automatic selection ensures appropriate uncertainty representation without requiring manual specification cases.","code":""},{"path":"/articles/plot_te.html","id":"bootstrap-confidence-intervals","dir":"Articles","previous_headings":"","what":"Bootstrap Confidence Intervals","title":"Plotting Triage Effectiveness Results","text":"Bootstrap confidence intervals available WTE RTE calculated bootstrap = TRUE parameter:","code":"# Calculate TE with bootstrap for both methods wte_bootstrap <- calc_wte(data, bootstrap = TRUE, overall_only = TRUE) #> [1] \"Starting bootstrap iterations 2025-04-21 14:53:25.496765\" #> [1] \"Bootstrap iterations done 2025-04-21 14:53:44.706691\" rte_bootstrap <- calc_rte(data, bootstrap = TRUE, overall_only = TRUE) #> [1] \"Starting RTE bootstrap with 2000 iterations, sample size 124311 at 2025-04-21 14:53:50.304543\" #> [1] \"RTE bootstrap completed at 2025-04-21 14:54:04.430496\"  # Plot with bootstrap confidence intervals wte_boot_plot <- plot_te(wte_bootstrap, title = \"WTE with Bootstrap CI\") rte_boot_plot <- plot_te(rte_bootstrap, title = \"RTE with Bootstrap CI\")  # Display plots wte_boot_plot / rte_boot_plot"},{"path":"/articles/plot_te.html","id":"subgroup-analysis","dir":"Articles","previous_headings":"","what":"Subgroup Analysis","title":"Plotting Triage Effectiveness Results","text":"WTE RTE support subgroup analysis. Let’s create age groups visualize TE patterns:","code":"# Create age groups data <- data %>%   mutate(age_group = cut(age_at_arrival,                          breaks = c(0, 59, 79, Inf),                         labels = c(\"18-59\", \"60-79\", \"80+\")))  # Calculate and plot TE by age group wte_age <- calc_wte(data, var1 = \"age_group\", bootstrap = TRUE, overall_only = TRUE) #> [1] \"Starting bootstrap iterations 2025-04-21 14:54:05.168835\" #> [1] \"Bootstrap iterations done 2025-04-21 14:54:24.849769\" rte_age <- calc_rte(data, var1 = \"age_group\", bootstrap = TRUE, overall_only = TRUE) #> [1] \"Starting RTE bootstrap with 2000 iterations, sample size 124311 at 2025-04-21 14:54:30.634843\" #> [1] \"RTE bootstrap completed at 2025-04-21 14:54:50.27291\"  # Create plots wte_age_plot <- plot_te(wte_age, title = \"WTE by Age Group\") rte_age_plot <- plot_te(rte_age, title = \"RTE by Age Group\")  # Display plots wte_age_plot / rte_age_plot"},{"path":"/articles/plot_te.html","id":"handling-negative-te-values","dir":"Articles","previous_headings":"","what":"Handling Negative TE Values","title":"Plotting Triage Effectiveness Results","text":"cases, particularly analyzing specific units, might encounter negative TE values. min_x parameter allows standardization x-axis range across multiple plots easier comparison:  Setting min_x ensures consistent scale alignment plots, making easier compare results across different units groups.","code":"# Get data for different units ortho_data <- data %>%    filter(unit == \"orthopedics\")  medical_data <- data %>%    filter(unit == \"medical\")   # Calculate WTE for both units wte_ortho <- calc_wte(ortho_data, bootstrap = TRUE) #> [1] \"Starting bootstrap iterations 2025-04-21 14:54:55.044274\" #> [1] \"Bootstrap iterations done 2025-04-21 14:55:02.682309\" wte_medical <- calc_wte(medical_data, bootstrap = TRUE) #> [1] \"Starting bootstrap iterations 2025-04-21 14:55:03.096863\" #> [1] \"Bootstrap iterations done 2025-04-21 14:55:14.183755\"  # Plot with default scaling - notice the different axes plot1 <- plot_te(wte_ortho, title = \"Orthopedics (default scaling)\") plot2 <- plot_te(wte_medical, title = \"Medical (default scaling)\")  # Plot with standardized x-axis plot3 <- plot_te(wte_ortho, min_x = -0.4, title = \"Orthopedics (standardized x-axis)\") plot4 <- plot_te(wte_medical, min_x = -0.4, title = \"Medical (standardized x-axis)\")  # Display plots showing the difference (plot1 / plot2) | (plot3 / plot4)"},{"path":"/articles/plot_te.html","id":"advanced-plot-customization","dir":"Articles","previous_headings":"","what":"Advanced Plot Customization","title":"Plotting Triage Effectiveness Results","text":"plot_te() function offers several customization options tailor visualizations specific needs. Let’s explore different parameters affect appearance:     Key customization parameters include: var_alpha: Controls transparency variability intervals (0-1) dumbell_width: Width lines connecting TTE OTE points var_width: Width variability interval main lines var_end_width: Width variability interval end caps var_end_height: Height variability interval end caps label_style: Can “none”, “small”, “full”, “half” (default) show_tte/show_ote: Toggle display specific metrics show_var: Toggle display variability intervals ci_vars_override: Control confidence interval type display details available parameters, see ?plot_te.","code":"# Base plot for comparison base_plot <- plot_te(wte_bootstrap, title = \"Default label style ('half')\")  # Different label styles small_labels <- plot_te(wte_bootstrap,                        label_style = \"small\",                        title = \"Small labels\")  full_labels <- plot_te(wte_bootstrap,                       label_style = \"full\",                       title = \"Full labels\")  no_labels <- plot_te(wte_bootstrap,                     label_style = \"none\",                     title = \"No labels\")  # Display label style variations base_plot / small_labels / full_labels / no_labels # Variability display options more_transparent <- plot_te(wte_bootstrap,                            var_alpha = 0.3,                            title = \"More transparent variability (alpha = 0.3)\")  less_transparent <- plot_te(wte_bootstrap,                            var_alpha = 0.8,                            title = \"Less transparent variability (alpha = 0.8)\")  # Display variability transparency variations more_transparent / less_transparent # Line width options thin_lines <- plot_te(wte_bootstrap,                      dumbell_width = 0.5,                      var_width = 0.8,                      var_end_width = 0.5,                      title = \"Thinner lines\")  thick_lines <- plot_te(wte_bootstrap,                       dumbell_width = 2,                       var_width = 2.5,                       var_end_width = 1.5,                       title = \"Thicker lines\")  # Display line width variations thin_lines / thick_lines # Selective display of metrics tte_only <- plot_te(wte_bootstrap,                    show_tte = TRUE,                    show_ote = FALSE,                    title = \"TTE only\")  ote_only <- plot_te(wte_bootstrap,                    show_tte = FALSE,                    show_ote = TRUE,                    title = \"OTE only\")  # Display selective metrics tte_only / ote_only"},{"path":"/articles/plot_te.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Plotting Triage Effectiveness Results","text":"vignette demonstrated : Create basic TE plots WTE RTE Understand control confidence interval types Visualize bootstrap confidence intervals Handle subgroup analyses Deal negative TE values Customize plot appearance complex analyses, consider combining visualization techniques methods described calc_wte_rte bootstrap vignettes.","code":""},{"path":"/articles/publications.html","id":"original-publication","dir":"Articles","previous_headings":"","what":"Original Publication","title":"Publications Using trieff","text":"[Details original publication added upon publication]","code":""},{"path":"/articles/publications.html","id":"related-publications","dir":"Articles","previous_headings":"","what":"Related Publications","title":"Publications Using trieff","text":"[section updated new publications emerge]","code":""},{"path":"/articles/sim_te.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Simulation in trieff","text":"trieff package uses simulation prestep Theoretical Triage Effectiveness (TTE) calculation modeling patients processed strictly following assigned priority levels. vignette explains simulation works demonstrates implementation.","code":""},{"path":[]},{"path":"/articles/sim_te.html","id":"key-concepts","dir":"Articles","previous_headings":"Understanding the Simulation","what":"Key Concepts","title":"Simulation in trieff","text":"simulation calculates theoretical wait times occur : Patients seen strictly order priority Within priority level, patients seen order arrival post-triage priority changes occurred","code":""},{"path":"/articles/sim_te.html","id":"optimized-implementation","dir":"Articles","previous_headings":"Understanding the Simulation","what":"Optimized Implementation","title":"Simulation in trieff","text":"default simulation (sim_te) optimizes performance focusing segments containing time-critical (LOSET-positive) cases. optimization works : WTE calculations, need determine waiting times LOSET-positive patients relative overall mean waiting time. overall mean can directly calculated observed wait times. RTE calculations, similarly need determine queue positions LOSET-positive patients. Non-LOSET segments impact RTE metrics. selective simulation approach dramatically reduces computation time without affecting accuracy TE results. segments without LOSET cases, function simply uses observed wait times, produces mathematically equivalent results fully simulating segments. research purposes complete queue behavior analysis needed, package also provides sim_te_alt simulates waiting times patients segments.","code":""},{"path":"/articles/sim_te.html","id":"basic-usage","dir":"Articles","previous_headings":"","what":"Basic Usage","title":"Simulation in trieff","text":"Let’s start basic example:","code":"# Initialize data data <- init(sem_malmo_synth)  # Run simulation simulated_data <- sim_te(data) #> [1] \"Filtered to 1486 segments with LOSET cases\" #> [1] \"Total LOSET cases: 5491\" #> [1] \"Starting multisession with 1 cores. 2025-04-21 14:55:22.234301\" #> [1] \"Simulations are done! 2025-04-21 14:55:27.081966\"  # Check first few rows simulated_data %>%    select(loset, observed_wait_time, theoretical_wait_time) %>%    head(10) #>    loset observed_wait_time theoretical_wait_time #> 1  FALSE                  0                     0 #> 2  FALSE                  0                     0 #> 3  FALSE                  7                     7 #> 4  FALSE                  3                     3 #> 5  FALSE                 60                    60 #> 6  FALSE                169                   126 #> 7  FALSE                114                    42 #> 8  FALSE                 58                    58 #> 9  FALSE                141                   141 #> 10 FALSE                  9                     0"},{"path":"/articles/sim_te.html","id":"simulation-parameters","dir":"Articles","previous_headings":"","what":"Simulation Parameters","title":"Simulation in trieff","text":"simulation accepts several parameters:","code":"simulated_data <- sim_te(   data,   tte = TRUE,     # Calculate theoretical wait times (default)   btte = FALSE,   # Skip binary theoretical calculations   n_workers = 1   # Number of cores for parallel processing, generally this is faster on 1 core. ) #> [1] \"Filtered to 1486 segments with LOSET cases\" #> [1] \"Total LOSET cases: 5491\" #> [1] \"Starting multisession with 1 cores. 2025-04-21 14:55:27.422334\" #> [1] \"Simulations are done! 2025-04-21 14:55:32.275236\""},{"path":"/articles/sim_te.html","id":"full-simulation-option","dir":"Articles","previous_headings":"Simulation Parameters","what":"Full Simulation Option","title":"Simulation in trieff","text":"research purposes theoretical wait times needed, can use sim_te_alt: full simulation calculates theoretical wait times cases takes slightly longer run. sharp eye might notice wait times look different shown example . sim_te (alt version) theoretical_waiting time set observed_waiting time segment without LOSET cases simulated. keeps mean waiting time identical columns.","code":"# Run full simulation full_sim_data <- sim_te_alt(data) #> [1] \"Starting multisession with 1 cores. 2025-04-21 14:55:32.550821\" #> [1] \"Simulations are done! 2025-04-21 14:55:46.588508\"  # First let's show that the mean observed and theoretical wait time is the same print(mean(full_sim_data$observed_wait_time)) #> [1] 79.39293 print(mean(full_sim_data$theoretical_wait_time)) #> [1] 79.39293  # Compare results full_sim_data %>%    select(loset, observed_wait_time, theoretical_wait_time) %>%    head(10) #>    loset observed_wait_time theoretical_wait_time #> 1  FALSE                  0                    60 #> 2  FALSE                  0                     0 #> 3  FALSE                  7                    36 #> 4  FALSE                  3                     3 #> 5  FALSE                 60                    60 #> 6  FALSE                169                   126 #> 7  FALSE                114                    42 #> 8  FALSE                 58                    45 #> 9  FALSE                141                   106 #> 10 FALSE                  9                     0"},{"path":"/articles/sim_te.html","id":"performance-considerations","dir":"Articles","previous_headings":"","what":"Performance Considerations","title":"Simulation in trieff","text":"optimized simulation offers significant performance benefits: Reduced computation focusing relevant segments Lower memory usage Faster parallel processing However, approaches produce identical TE values:","code":"# Calculate TE with both methods te_opt <- calc_wte(simulated_data, overall_only = TRUE) te_full <- calc_wte(full_sim_data, overall_only = TRUE)  # Compare results print(te_opt) #>  #> Triage Effectiveness Analysis Results #> =================================== #>  #> Results for Overall  #> -------------------  #> Total patients: 124311 (4.4% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 73.7% #>   Specificity: 65.9% #>  #> Triage Effectiveness Metrics: #>   OTE: 29.9% #>   TTE: 52.8% #>   OTG: -23.0% #>  #> Computation Information #> ===================== #> Method: Direct calculation (waiting-time-based) #> Calculation time: 2025-04-21 14:55:48.213642 print(te_full) #>  #> Triage Effectiveness Analysis Results #> =================================== #>  #> Results for Overall  #> -------------------  #> Total patients: 124311 (4.4% LOSET positive) #>  #> Classification Metrics: #>   Sensitivity: 73.7% #>   Specificity: 65.9% #>  #> Triage Effectiveness Metrics: #>   OTE: 29.9% #>   TTE: 52.8% #>   OTG: -23.0% #>  #> Computation Information #> ===================== #> Method: Direct calculation (waiting-time-based) #> Calculation time: 2025-04-21 14:55:48.244409"},{"path":"/articles/sim_te.html","id":"when-to-use-each-approach","dir":"Articles","previous_headings":"","what":"When to Use Each Approach","title":"Simulation in trieff","text":"Use sim_te (default) : Calculating TE metrics Processing large datasets Use sim_te_alt : Researching queue behavior Analyzing non-LOSET wait patterns Validating simulation methods","code":""},{"path":"/articles/sim_te.html","id":"technical-details","dir":"Articles","previous_headings":"","what":"Technical Details","title":"Simulation in trieff","text":"simulation uses non-preemptive approach : physician contact becomes available time slot Patients queued priority arrival time Wait times calculated slot assignment deterministic approach ensures reproducible results accurately modeling priority-based queuing.","code":""},{"path":"/articles/sim_te.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Simulation in trieff","text":"Understanding simulation trieff helps : Choose appropriate simulation method Interpret results correctly Optimize performance use case applications, default sim_te provides efficient path accurate TE calculation.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"André Johansson. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Johansson (2025). trieff: Triage Effectiveness Analysis Emergency Departments. R package version 1.1.0, https://AndreJohanssonLund.github.io/trieff/.","code":"@Manual{,   title = {trieff: Triage Effectiveness Analysis for Emergency Departments},   author = {André Johansson},   year = {2025},   note = {R package version 1.1.0},   url = {https://AndreJohanssonLund.github.io/trieff/}, }"},{"path":[]},{"path":"/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"TriEff - Triage Effectiveness Framework","text":"TriEff provides tools analyzing evaluating triage effectiveness emergency departments. core, measures well triage systems achieve fundamental purpose: reducing waiting times time-critical patients. get started see vignette(\"getting_started\")","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"TriEff - Triage Effectiveness Framework","text":"can install TriEff github like :","code":"# install.packages(\"devtools\") devtools::install_github(\"AndreJohanssonLund/trieff\")"},{"path":"/reference/analyze_bootstrap_convergence.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze Bootstrap Convergence — analyze_bootstrap_convergence","title":"Analyze Bootstrap Convergence — analyze_bootstrap_convergence","text":"Analyze Bootstrap Convergence","code":""},{"path":"/reference/analyze_bootstrap_convergence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze Bootstrap Convergence — analyze_bootstrap_convergence","text":"","code":"analyze_bootstrap_convergence(   results,   subgroup = NULL,   var1 = NULL,   var2 = NULL )"},{"path":"/reference/analyze_bootstrap_convergence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze Bootstrap Convergence — analyze_bootstrap_convergence","text":"results List containing bootstrap results calc_te subgroup Optional list defining subgroup criteria var1 Optional string first comparison variable var2 Optional string second comparison variable","code":""},{"path":"/reference/analyze_bootstrap_convergence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze Bootstrap Convergence — analyze_bootstrap_convergence","text":"List containing: groups: Tibble group-level convergence results summary: Overall convergence statistics metrics_analyzed: Vector analyzed TE metrics calculation_time: Timestamp analysis","code":""},{"path":"/reference/analyze_bootstrap_convergence.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analyze Bootstrap Convergence — analyze_bootstrap_convergence","text":"Analyzes convergence stability bootstrap iterations calculating running means, standard errors, confidence intervals group.","code":""},{"path":"/reference/calc_rte.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Rank-based Triage Effectiveness (RTE) — calc_rte","title":"Calculate Rank-based Triage Effectiveness (RTE) — calc_rte","text":"Calculates Rank-based Triage Effectiveness (RTE) metrics, evaluate triage performance based patient queue positions rather waiting times. RTE provides patient-level metric complements waiting time-based Triage Effectiveness (WTE) approach.","code":""},{"path":"/reference/calc_rte.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Rank-based Triage Effectiveness (RTE) — calc_rte","text":"","code":"calc_rte(   df,   subgroup = NULL,   var1 = NULL,   var2 = NULL,   bootstrap = FALSE,   bootstrap_params = list(sample_percentage = 1, n_iterations = 2000, distribution_span =     0.95),   n_workers = parallel::detectCores() - 1,   verbose = FALSE,   overall_only = FALSE,   min_loset_warning = 5,   include_distributions = TRUE,   check_convergence = TRUE,   seed = NULL,   quite = TRUE )"},{"path":"/reference/calc_rte.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Rank-based Triage Effectiveness (RTE) — calc_rte","text":"df Data frame containing patient data (must initialized init()) subgroup Optional list subgroup analysis - alternative var1/2 var1 Optional string first comparison variable var2 Optional string second comparison variable bootstrap Logical. Whether perform bootstrap calculations. Default FALSE. bootstrap_params List bootstrap parameters: sample_percentage (default: 1) large sample used? 1 = full sample. n_iterations (default: 2000) many bootstrap iterations use distribution_span (default: 0.95) confidence interval used? n_workers Number workers parallel processing (default: detectCores() - 1) verbose Logical. TRUE, returns detailed results intermediate calculation fields calculate_queue_metrics. Default FALSE. overall_only Logical. TRUE, overall metrics returned (default: FALSE) min_loset_warning Numerical, function warn low loset prevalence? (default: 5) include_distributions Logical. TRUE, returns patient-level RTE values analysis bootstrap distrobutions. Default FALSE. check_convergence Logical, Default TRUE. check convergence produce convergence plots true + bootstrap == TRUE. seed Seed reproducible bootstrapping (default: NULL - seed) quite Logical. Default TRUE. false outputs recommended/used confidence interval choice.","code":""},{"path":"/reference/calc_rte.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Rank-based Triage Effectiveness (RTE) — calc_rte","text":"list containing: results: Tibble RTE metrics metadata: List containing calculation parameters distributions: (include_distributions=TRUE) Patient-level RTE values","code":""},{"path":"/reference/calc_te.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Triage Effectiveness — calc_te","title":"Calculate Triage Effectiveness — calc_te","text":"Calculates triage effectiveness metrics including Observed Triage Effectiveness (OTE), Theoretical Triage Effectiveness (TTE), bootstrap confidence intervals requested. Note separate help section convergence documentation.","code":""},{"path":"/reference/calc_te.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Triage Effectiveness — calc_te","text":"","code":"calc_te(   df,   subgroup = NULL,   var1 = NULL,   var2 = NULL,   bootstrap = FALSE,   bootstrap_params = list(sample_percentage = 1, n_iterations = 2000, distribution_span =     0.95),   n_workers = parallel::detectCores() - 1,   overall_only = FALSE,   check_convergence = TRUE,   min_loset_warning = 5,   seed = NULL )"},{"path":"/reference/calc_te.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Triage Effectiveness — calc_te","text":"df Data frame containing patient data (must initialized init()) subgroup Optional list subgroup analysis - alternative var1/2 var1 Optional string first comparison variable var2 Optional string second comparison variable bootstrap Logical character. Whether perform bootstrap calculations method use: FALSE: bootstrapping (default) TRUE \"standard\": Standard patient-level bootstrapping \"segment\": custom type Block bootstrapping using queue segments bootstrap_params List bootstrap parameters: sample_percentage (default: 1) large sample used? 1 = full sample. segment bootstrapping reffers percentage samples used n_iterations (default: 2000) many bootstrap iterations use distribution_span (default: 0.95) confidence interval used? n_workers Number workers parallel processing (default: detectCores() - 1) overall_only Logical. TRUE, overall metrics returned (default: FALSE) check_convergence Logical. true return list convergence plots, bootstrap done (default: TRUE) min_loset_warning Numerical, function warn low loset prevalence? (default: 5) seed Seed reproducible bootstrapping (default: NULL - seed)","code":""},{"path":"/reference/calc_te.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Triage Effectiveness — calc_te","text":"list containing: results: Tibble TE metrics: unit: Medical specialty unit \"overall\" combined results n_patients: Total number patients group n_patients_loset: Number LOSET-positive (time-critical) patients loset_prevalence: Proportion LOSET-positive patients mean_all: Mean waiting time patients ote_mean_loset: Mean observed waiting time LOSET patients ote_te: Observed Triage Effectiveness tte_mean_loset: Mean theoretical waiting time LOSET patients tte_te: Theoretical Triage Effectiveness btte_mean_loset: Mean binary theoretical waiting time LOSET patients btte_te: Binary Theoretical Triage Effectiveness otg_te: Observed-Theoretical Gap (ote_te - tte_te) sensitivity: True positive rate identifying time-critical patients specificity: True negative rate identifying non-time-critical patients boot_ote_mean: Bootstrap mean OTE (bootstrap=TRUE) boot_ote_sd: Bootstrap standard deviation OTE boot_ote_sd_q: Robust standard deviation OTE based IQR, Calculated IQR/1.349 boot_ote_var_lower: Lower bound OTE confidence interval boot_ote_var_upper: Upper bound OTE confidence interval boot_tte_mean: Bootstrap mean TTE boot_tte_sd: Bootstrap standard deviation TTE boot_tte_sd_q: Robust standard deviation TTE based IQR, Calculated IQR/1.349 boot_tte_var_lower: Lower bound TTE confidence interval boot_tte_var_upper: Upper bound TTE confidence interval boot_btte_mean: Bootstrap mean BTTE boot_btte_sd: Bootstrap standard deviation BTTE boot_btte_sd_q: Robust standard deviation BTTE based IQR, Calculated IQR/1.349 boot_btte_var_lower: Lower bound BTTE confidence interval boot_btte_var_upper: Upper bound BTTE confidence interval boot_mean_n_patients: Mean number patients across bootstrap samples boot_mean_n_loset: Mean number LOSET patients across bootstrap samples metadata: List containing calculation parameters: calculation_time: Timestamp calculation performed bootstrap_params: List parameters used bootstrap (applicable): sample_percentage: Fraction data used bootstrap iteration n_iterations: Number bootstrap iterations performed distribution_span: Width confidence intervals (e.g., 0.95 95% CI) bootstrap_method: Type bootstrap method use - standard segment (applicable) group_var1: First grouping variable used () group_var2: Second grouping variable used () subgr: Subgroup criteria used () bootstrap_distributions: Full bootstrap iteration data (bootstrap=TRUE) convergence: Convergence analysis results (check_convergence=TRUE)","code":""},{"path":"/reference/calc_te.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Triage Effectiveness — calc_te","text":"","code":"if (FALSE) { # \\dontrun{ # Basic calculation te_results <- calc_te(patient_data)  # With bootstrap te_results <- calc_te(patient_data,                      bootstrap = TRUE)  # With subgroup analysis te_results <- calc_te(patient_data,                      subgroup = list(age_group = \"elderly\")) } # }"},{"path":"/reference/calc_wte.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Triage Effectiveness — calc_wte","title":"Calculate Triage Effectiveness — calc_wte","text":"Calculates triage effectiveness metrics including Observed Triage Effectiveness (OTE), Theoretical Triage Effectiveness (TTE), bootstrap confidence intervals requested. Note separate help section convergence documentation.","code":""},{"path":"/reference/calc_wte.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Triage Effectiveness — calc_wte","text":"","code":"calc_wte(   df,   subgroup = NULL,   var1 = NULL,   var2 = NULL,   bootstrap = FALSE,   bootstrap_params = list(sample_percentage = 1, n_iterations = 2000, distribution_span =     0.95),   n_workers = parallel::detectCores() - 1,   overall_only = FALSE,   check_convergence = TRUE,   min_loset_warning = 5,   seed = NULL )"},{"path":"/reference/calc_wte.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Triage Effectiveness — calc_wte","text":"df Data frame containing patient data (must initialized init()) subgroup Optional list subgroup analysis - alternative var1/2 var1 Optional string first comparison variable var2 Optional string second comparison variable bootstrap Logical character. Whether perform bootstrap calculations method use: FALSE: bootstrapping (default) TRUE \"standard\": Standard patient-level bootstrapping \"segment\": custom type Block bootstrapping using queue segments bootstrap_params List bootstrap parameters: sample_percentage (default: 1) large sample used? 1 = full sample. segment bootstrapping reffers percentage samples used n_iterations (default: 2000) many bootstrap iterations use distribution_span (default: 0.95) confidence interval used? n_workers Number workers parallel processing (default: detectCores() - 1) overall_only Logical. TRUE, overall metrics returned (default: FALSE) check_convergence Logical. true return list convergence plots, bootstrap done (default: TRUE) min_loset_warning Numerical, function warn low loset prevalence? (default: 5) seed Seed reproducible bootstrapping (default: NULL - seed)","code":""},{"path":"/reference/calc_wte.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Triage Effectiveness — calc_wte","text":"list containing: results: Tibble TE metrics: unit: Medical specialty unit \"overall\" combined results n_patients: Total number patients group n_patients_loset: Number LOSET-positive (time-critical) patients loset_prevalence: Proportion LOSET-positive patients mean_all: Mean waiting time patients ote_mean_loset: Mean observed waiting time LOSET patients ote_te: Observed Triage Effectiveness tte_mean_loset: Mean theoretical waiting time LOSET patients tte_te: Theoretical Triage Effectiveness btte_mean_loset: Mean binary theoretical waiting time LOSET patients btte_te: Binary Theoretical Triage Effectiveness otg_te: Observed-Theoretical Gap (ote_te - tte_te) sensitivity: True positive rate identifying time-critical patients specificity: True negative rate identifying non-time-critical patients boot_ote_mean: Bootstrap mean OTE (bootstrap=TRUE) boot_ote_sd: Bootstrap standard deviation OTE boot_ote_sd_q: Robust standard deviation OTE based IQR, Calculated IQR/1.349 boot_ote_var_lower: Lower bound OTE confidence interval boot_ote_var_upper: Upper bound OTE confidence interval boot_tte_mean: Bootstrap mean TTE boot_tte_sd: Bootstrap standard deviation TTE boot_tte_sd_q: Robust standard deviation TTE based IQR, Calculated IQR/1.349 boot_tte_var_lower: Lower bound TTE confidence interval boot_tte_var_upper: Upper bound TTE confidence interval boot_btte_mean: Bootstrap mean BTTE boot_btte_sd: Bootstrap standard deviation BTTE boot_btte_sd_q: Robust standard deviation BTTE based IQR, Calculated IQR/1.349 boot_btte_var_lower: Lower bound BTTE confidence interval boot_btte_var_upper: Upper bound BTTE confidence interval boot_mean_n_patients: Mean number patients across bootstrap samples boot_mean_n_loset: Mean number LOSET patients across bootstrap samples metadata: List containing calculation parameters: calculation_time: Timestamp calculation performed bootstrap_params: List parameters used bootstrap (applicable): sample_percentage: Fraction data used bootstrap iteration n_iterations: Number bootstrap iterations performed distribution_span: Width confidence intervals (e.g., 0.95 95% CI) bootstrap_method: Type bootstrap method use - standard segment (applicable) group_var1: First grouping variable used () group_var2: Second grouping variable used () subgr: Subgroup criteria used () bootstrap_distributions: Full bootstrap iteration data (bootstrap=TRUE) convergence: Convergence analysis results (check_convergence=TRUE)","code":""},{"path":"/reference/calc_wte.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Triage Effectiveness — calc_wte","text":"","code":"if (FALSE) { # \\dontrun{ # Basic calculation te_results <- calc_te(patient_data)  # With bootstrap te_results <- calc_te(patient_data,                      bootstrap = TRUE)  # With subgroup analysis te_results <- calc_te(patient_data,                      subgroup = list(age_group = \"elderly\")) } # }"},{"path":"/reference/calculate_bootstrap_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Bootstrap Metrics for Triage Effectiveness — calculate_bootstrap_metrics","title":"Calculate Bootstrap Metrics for Triage Effectiveness — calculate_bootstrap_metrics","text":"function performs bootstrap analysis Triage Effectiveness data, calculating confidence intervals statistical properties TE metrics.","code":""},{"path":"/reference/calculate_bootstrap_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Bootstrap Metrics for Triage Effectiveness — calculate_bootstrap_metrics","text":"","code":"calculate_bootstrap_metrics(results, results_df, bootstrap_params, method)"},{"path":"/reference/calculate_bootstrap_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Bootstrap Metrics for Triage Effectiveness — calculate_bootstrap_metrics","text":"results list containing complete calculation results results_df data frame containing summarized TE results bootstrap_params list containing bootstrap parameters: sample_percentage: Percentage data sample iteration n_iterations: Number bootstrap iterations distribution_span: Width confidence interval method Character string specifying bootstrap method (\"standard\" \"segment\")","code":""},{"path":"/reference/calculate_bootstrap_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Bootstrap Metrics for Triage Effectiveness — calculate_bootstrap_metrics","text":"modified results data frame added bootstrap metrics","code":""},{"path":"/reference/calculate_overall_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Overall TE Metrics — calculate_overall_metrics","title":"Calculate Overall TE Metrics — calculate_overall_metrics","text":"Calculate Overall TE Metrics","code":""},{"path":"/reference/calculate_overall_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Overall TE Metrics — calculate_overall_metrics","text":"","code":"calculate_overall_metrics(unit_results, overall_grouping)"},{"path":"/reference/calculate_overall_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Overall TE Metrics — calculate_overall_metrics","text":"unit_results Results unit-level calculations overall_grouping Grouped data frame overall calculations","code":""},{"path":"/reference/calculate_overall_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Overall TE Metrics — calculate_overall_metrics","text":"Tibble overall TE metrics","code":""},{"path":"/reference/calculate_overall_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Overall TE Metrics — calculate_overall_metrics","text":"Calculates overall metrics using weighted means based number LOSET patients unit.","code":""},{"path":"/reference/calculate_queue_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Queue Metrics for Rank-based Triage Effectiveness (RTE) Analysis — calculate_queue_metrics","title":"Calculate Queue Metrics for Rank-based Triage Effectiveness (RTE) Analysis — calculate_queue_metrics","text":"function implements Rank-based Triage Effectiveness (RTE) methodology evaluate triage system performance based patient queue positioning rather waiting times. RTE measures effectively triage system prioritizes time-critical patients relative positions theoretical first-come-first-served system, providing patient-level metric complements waiting time-based Triage Effectiveness (WTE) approach.","code":""},{"path":"/reference/calculate_queue_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Queue Metrics for Rank-based Triage Effectiveness (RTE) Analysis — calculate_queue_metrics","text":"","code":"calculate_queue_metrics(   data,   verbose = TRUE,   ambiguity_invalid = TRUE,   ambiguity_perfect = TRUE )"},{"path":"/reference/calculate_queue_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Queue Metrics for Rank-based Triage Effectiveness (RTE) Analysis — calculate_queue_metrics","text":"data data frame initiated init() following required columns: segment: Created init(), grouping variable identifying distinct queue segments. arrival_minute: Time patient arrival (numeric). observed_resolve_time: Time patient actually resolved (numeric), created init(). theoretica_resolve_time: Theoretical resolution time (numeric) sim_te(). Optional. binary_theoretical_resolve_time: Theoretical resolution time using binary priorities (numeric). Optional. loset: Logical flag indicating patient time-critical (TRUE) (FALSE). verbose logical, determines intermediate calculation fields returned (TRUE) final RTE results (FALSE). ambiguity_invalid logical, default TRUE, sets cases n_tc => L invalid since ambigous thus used draw conclusions. .e. p = 1 theoretically gives TE = 100% 0%. ambiguity_perfect logical, default TRUE, used ambiguity_invalit == FALSE, TRUE, cases n_tc => L gives 100% TE, false, gives 0% TE.","code":""},{"path":"/reference/calculate_queue_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Queue Metrics for Rank-based Triage Effectiveness (RTE) Analysis — calculate_queue_metrics","text":"data frame original data plus additional columns: arrivals_up_to_now: (verbose == TRUE) Cumulative count arrivals patient's arrival time. observed_resolves_before: (verbose == TRUE) Count patients resolved patient's arrival. L: (verbose == TRUE) Queue length patient arrival (including patient). observed_p: (verbose == TRUE) Patient's position resolution sequence, counting arrival observed resolution. theoretical_p: (verbose == TRUE) Patient's position theoretical resolution sequence. n_tc: (verbose == TRUE) Number time-critical patients concurrent window (last resolve arrival first resolve ). is_cluster: Logical flag indicating patient part time-critical cluster. cluster_id: Identifier patients belonging time-critical cluster. valid: Logical flag indicating time-critical patient's RTE calculation valid (see details). observed_RTE: Rank-based Triage Effectiveness based observed resolution times (NA non-time-critical patients). theoretical_RTE: Rank-based Triage Effectiveness based theoretical resolution times (NA non-time-critical patients).","code":""},{"path":[]},{"path":"/reference/calculate_queue_metrics.html","id":"conceptual-framework","dir":"Reference","previous_headings":"","what":"Conceptual Framework","title":"Calculate Queue Metrics for Rank-based Triage Effectiveness (RTE) Analysis — calculate_queue_metrics","text":"RTE quantifies triage performance queue positioning rather waiting times. evaluates effectively triage system moves time-critical patients forward resolution queue compared position first-come-first-served (FCFS) system, : RTE = 0 means patient's position equivalent FCFS (triage benefit) RTE = 1 means optimal positioning (perfect triage) RTE < 0 means worse positioning FCFS (triage counterproductive)","code":""},{"path":"/reference/calculate_queue_metrics.html","id":"key-metrics-calculation","dir":"Reference","previous_headings":"","what":"Key Metrics Calculation","title":"Calculate Queue Metrics for Rank-based Triage Effectiveness (RTE) Analysis — calculate_queue_metrics","text":"L (Queue Length): Represents number patients queue patient arrives, including patient . value indicates position patient FCFS system. p (Position): patient's position resolution sequence, counting arrival time resolution time. p value 1 means patient first resolved among patients queue arrival time. n_tc: Number time-critical patients (loset=TRUE) concurrent window last resolve patient's arrival first resolve arrival, including patient . represents \"cluster\" time-critical cases arrived close temporal proximity. valid: time-critical patient's RTE calculation considered valid triage can make meaningful difference. Specifically, calculation valid conditions met: least one non-time-critical patient already queue arrival time, non-time-critical patient arrive L resolves happen (L = n_tc), L ≠ n_tc (queue composition allows meaningful prioritization) validation prevents analysis scenarios order matter (e.g., patients queue time-critical new non-time-critical patients arrive resolved).","code":""},{"path":"/reference/calculate_queue_metrics.html","id":"rte-calculation-logic","dir":"Reference","previous_headings":"","what":"RTE Calculation Logic","title":"Calculate Queue Metrics for Rank-based Triage Effectiveness (RTE) Analysis — calculate_queue_metrics","text":"RTE formula varies depending queue dynamics ensure consistent interpretation across different scenarios: Perfect Triage (p ≤ n_tc): patient resolved within first n_tc positions n_tc ≥ L ambiguity_perfect=TRUE: RTE = 1 (perfect score) n_tc ≥ L ambiguity_perfect=FALSE: RTE = 0 Otherwise (n_tc < L): RTE = 1 (perfect score) Positive Triage (n_tc < p ≤ L): patient resolved first n_tc positions within L RTE = (L - p) / (L - n_tc) Negative Triage (p > L): patient resolved L positions (worse first-come, first-served) RTE = (L - p) / L (negative)","code":""},{"path":"/reference/calculate_queue_metrics.html","id":"ambiguity-handling","dir":"Reference","previous_headings":"","what":"Ambiguity Handling","title":"Calculate Queue Metrics for Rank-based Triage Effectiveness (RTE) Analysis — calculate_queue_metrics","text":"ambiguous case occurs n_tc ≥ L, meaning many time-critical patients queue length. situation, position perfect prioritization first-come, first-serve system. default (ambiguity_invalid=TRUE), cases considered invalid RTE calculation. ambiguity_invalid=FALSE, result depends ambiguity_perfect: ambiguity_perfect=TRUE (default): cases scored \"perfect\" (RTE = 1) ambiguity_perfect=FALSE: cases scored \"zero\" (RTE = 0)","code":""},{"path":"/reference/calculate_queue_metrics.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Queue Metrics for Rank-based Triage Effectiveness (RTE) Analysis — calculate_queue_metrics","text":"Example 1: time-critical patient arrives finds 5 patients already queue (L = 6). time-critical patient window (n_tc = 1). get resolved 2nd patient (p = 2). Using case 3 formula: RTE = (6 - 2)/(6 - (1+1)/2) = 4/5 = 0.8 indicates good triage performance, moving patient nearly optimal position. Example 2: time-critical patient arrives empty queue (L = 1) time-critical patient (n_tc = 1). patient resolved, 3 non-time-critical patients arrive. time-critical patient gets resolved 3rd patient (p = 3). Using case 4 formula: RTE = (1 + ((1+1)/2-1) - 3)/1 = -1.5 indicates poor triage, time-critical patient significantly delayed despite arriving first. Example 3: major incident, 4 time-critical patients arrive rapid succession ED 2 patients already waiting (L = 3 first arriving time-critical patient, n_tc = 4). first time-critical patient gets resolved 2nd patient (p = 2). Using case 2 formula: RTE = ((4+1)/2 - 2)/((4+1)/2 - 1) = 0.5/1.5 = 0.33 indicates moderate triage performance within context time-critical patient cluster.","code":""},{"path":"/reference/calculate_queue_metrics.html","id":"differences-between-rank-based-te-rte-and-waiting-time-based-te-wte-","dir":"Reference","previous_headings":"","what":"Differences between Rank-based TE (RTE) and Waiting time-based TE (WTE)","title":"Calculate Queue Metrics for Rank-based Triage Effectiveness (RTE) Analysis — calculate_queue_metrics","text":"Conceptual Focus: RTE measures position improvement queue (process metric) WTE measures waiting time reduction (outcome metric) Analytical Granularity: RTE provides patient-level measurements, enabling standard statistical analyses without bootstrapping WTE produces aggregate measurements requiring bootstrapping confidence intervals Queue Dynamics Handling: RTE handles non-coincident arrivals resolves better WTE WTE better reflects actual time impact experienced patients Edge Case Behavior: RTE can punish placement severely short queues time effect minimal WTE can punish EDs lower resolve rates fewer priority 1 cases System Evaluation: RTE focuses specifically triage decision quality regardless system throughput WTE combines effects triage decisions system throughput capacity Interpretation Differences: RTE measures position advantage relative FCFS position cluster composition WTE measures time advantage relative mean waiting time patients Cross-System Comparison: RTE may stable across different ED environments varying throughput capacities WTE directly reflects patient experience terms actual waiting time","code":""},{"path":"/reference/calculate_queue_metrics.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate Queue Metrics for Rank-based Triage Effectiveness (RTE) Analysis — calculate_queue_metrics","text":"function makes specific assumptions handling multiple patients resolved minute: observed_p calculation: multiple patients resolved minute, function assumes higher priority patients resolved first, followed patients equal priority arrival order. may reflect actual sequence occurred practice, level detail often captured typical ED datasets minute-level resolution. calculation therefore interprets observed data \"best light\" - assuming ideal priority-based ordering within minute. theoretical_p binary_theoretical_p: priority-based ordering consistent simulation used sim_te() sim_heat(), ensuring within minute, higher priority patients always processed lower priority patients, equal priority patients processed arrival order. Cluster handling: function identifies time-critical clusters multiple time-critical cases (n_tc > 1) least one n_tc > L. Patients clusters evaluated using modified RTE formula better accounts unique dynamics clustered time-critical arrivals. handling necessary achieve consistent 100% TE scores scenarios perfect triage (100% sensitivity specificity), particularly multiple patients resolved within minute time-critical patients arrive clusters. function makes specific assumptions handling multiple patients resolved minute: observed_p calculation: multiple patients resolved minute, function assumes higher priority patients resolved first, followed patients equal priority arrival order. may reflect actual sequence occurred practice, level detail often captured typical ED datasets minute-level resolution. calculation therefore interprets observed data \"best light\" - assuming ideal priority-based ordering within minute. theoretical_p binary_theoretical_p: priority-based ordering consistent simulation used sim_te() sim_heat(), ensuring within minute, higher priority patients always processed lower priority patients, equal priority patients processed arrival order. handling necessary achieve consistent 100% TE scores scenarios perfect triage (100% sensitivity specificity), particularly multiple patients resolved within minute.","code":""},{"path":[]},{"path":"/reference/calculate_reference_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Reference Values for TE Calculations — calculate_reference_values","title":"Calculate Reference Values for TE Calculations — calculate_reference_values","text":"Calculate Reference Values TE Calculations","code":""},{"path":"/reference/calculate_reference_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Reference Values for TE Calculations — calculate_reference_values","text":"","code":"calculate_reference_values(df, subgroup = NULL, var1 = NULL, var2 = NULL)"},{"path":"/reference/calculate_reference_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Reference Values for TE Calculations — calculate_reference_values","text":"df Data frame containing patient data subgroup Optional list subgroup analysis var1 Optional string first comparison variable var2 Optional string second comparison variable","code":""},{"path":"/reference/calculate_reference_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Reference Values for TE Calculations — calculate_reference_values","text":"tibble containing: Grouping variables (unit comparison variables) mean_all: Mean waiting time group n_loset: Number loset cases group","code":""},{"path":"/reference/calculate_reference_values.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Reference Values for TE Calculations — calculate_reference_values","text":"Calculates essential reference values needed TE calculations using grouping structure main calculations.","code":""},{"path":"/reference/calculate_rte_bootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate RTE Bootstrap Metrics — calculate_rte_bootstrap","title":"Calculate RTE Bootstrap Metrics — calculate_rte_bootstrap","text":"Calculate RTE Bootstrap Metrics","code":""},{"path":"/reference/calculate_rte_bootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate RTE Bootstrap Metrics — calculate_rte_bootstrap","text":"","code":"calculate_rte_bootstrap(   df,   subgroup = NULL,   var1 = NULL,   var2 = NULL,   bootstrap_params,   n_workers,   seed = NULL )"},{"path":"/reference/calculate_rte_bootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate RTE Bootstrap Metrics — calculate_rte_bootstrap","text":"df Data frame containing patient data subgroup Optional list subgroup analysis var1 Optional string first comparison variable var2 Optional string second comparison variable bootstrap_params List bootstrap parameters n_workers Number workers parallel processing seed Seed reproducible bootstrapping","code":""},{"path":"/reference/calculate_rte_bootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate RTE Bootstrap Metrics — calculate_rte_bootstrap","text":"List containing bootstrap metrics distributions","code":""},{"path":"/reference/calculate_rte_bootstrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate RTE Bootstrap Metrics — calculate_rte_bootstrap","text":"Performs bootstrap resampling patients recalculates RTE metrics bootstrap sample. approach mirrors WTE bootstrap method capturing uncertainty overall metric rather just patient-level values.","code":""},{"path":"/reference/calculate_rte_overall_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate RTE Overall Metrics — calculate_rte_overall_metrics","title":"Calculate RTE Overall Metrics — calculate_rte_overall_metrics","text":"Calculate RTE Overall Metrics","code":""},{"path":"/reference/calculate_rte_overall_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate RTE Overall Metrics — calculate_rte_overall_metrics","text":"","code":"calculate_rte_overall_metrics(unit_results, df, overall_grouping = NULL)"},{"path":"/reference/calculate_rte_overall_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate RTE Overall Metrics — calculate_rte_overall_metrics","text":"unit_results Results unit-level calculations df Original patient data frame RTE values overall_grouping Grouped data frame overall calculations","code":""},{"path":"/reference/calculate_rte_overall_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate RTE Overall Metrics — calculate_rte_overall_metrics","text":"Tibble overall RTE metrics","code":""},{"path":"/reference/calculate_rte_overall_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate RTE Overall Metrics — calculate_rte_overall_metrics","text":"Calculates overall metrics combining unit results appropriate weighting. bootstrap results, uses patient-weighted means accurate estimate.","code":""},{"path":"/reference/calculate_rte_segment_bootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate RTE with Segment Bootstrap — calculate_rte_segment_bootstrap","title":"Calculate RTE with Segment Bootstrap — calculate_rte_segment_bootstrap","text":"Calculate RTE Segment Bootstrap","code":""},{"path":"/reference/calculate_rte_segment_bootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate RTE with Segment Bootstrap — calculate_rte_segment_bootstrap","text":"","code":"calculate_rte_segment_bootstrap(   df,   subgroup = NULL,   var1 = NULL,   var2 = NULL,   bootstrap_params,   n_workers,   seed = NULL )"},{"path":"/reference/calculate_rte_segment_bootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate RTE with Segment Bootstrap — calculate_rte_segment_bootstrap","text":"df Data frame containing patient data subgroup Optional list subgroup analysis var1 Optional string first comparison variable var2 Optional string second comparison variable bootstrap_params List bootstrap parameters n_workers Number workers parallel processing seed Seed reproducible bootstrapping","code":""},{"path":"/reference/calculate_rte_segment_bootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate RTE with Segment Bootstrap — calculate_rte_segment_bootstrap","text":"List containing bootstrap metrics distributions","code":""},{"path":"/reference/calculate_rte_segment_bootstrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate RTE with Segment Bootstrap — calculate_rte_segment_bootstrap","text":"Performs segment-based bootstrap RTE calculations, entire queue segments resampled rather individual patients. preserves queue dynamics estimating uncertainty RTE metrics.","code":""},{"path":"/reference/calculate_rte_unit_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Unit-Level RTE Metrics — calculate_rte_unit_metrics","title":"Calculate Unit-Level RTE Metrics — calculate_rte_unit_metrics","text":"Calculate Unit-Level RTE Metrics","code":""},{"path":"/reference/calculate_rte_unit_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Unit-Level RTE Metrics — calculate_rte_unit_metrics","text":"","code":"calculate_rte_unit_metrics(grouping)"},{"path":"/reference/calculate_rte_unit_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Unit-Level RTE Metrics — calculate_rte_unit_metrics","text":"grouping Grouped data frame including unit comparison variables","code":""},{"path":"/reference/calculate_rte_unit_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Unit-Level RTE Metrics — calculate_rte_unit_metrics","text":"Tibble unit-level RTE metrics","code":""},{"path":"/reference/calculate_rte_unit_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Unit-Level RTE Metrics — calculate_rte_unit_metrics","text":"Calculates unit-level metrics including: Patient counts valid RTE counts Mean RTE values observed, theoretical, binary theoretical Parametric non-parametric confidence intervals Normality test results","code":""},{"path":"/reference/calculate_te.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Triage Effectiveness Metrics — calculate_te","title":"Calculate Triage Effectiveness Metrics — calculate_te","text":"Calculate Triage Effectiveness Metrics","code":""},{"path":"/reference/calculate_te.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Triage Effectiveness Metrics — calculate_te","text":"","code":"calculate_te(df, subgroup = NULL, var1 = NULL, var2 = NULL, min_loset_warning)"},{"path":"/reference/calculate_te.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Triage Effectiveness Metrics — calculate_te","text":"df data frame containing patient data (must initialized init()) subgroup Optional list defining subgroup criteria var1 Optional string naming first comparison variable var2 Optional string naming second comparison variable min_loset_warning sent check valid amount loset cases exists.","code":""},{"path":"/reference/calculate_te.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Triage Effectiveness Metrics — calculate_te","text":"tibble containing: Unit-level metrics (priority counts, patient counts, LOSET prevalence) OTE (Observed Triage Effectiveness) metrics TTE (Theoretical Triage Effectiveness) metrics available BTTE (Binary Theoretical Triage Effectiveness) metrics available Sensitivity specificity values Overall metrics across units","code":""},{"path":"/reference/calculate_te.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Triage Effectiveness Metrics — calculate_te","text":"Internal implementation function performs core TE calculations. Creates unit-level metrics overall metrics using weighted means based number LOSET patients. function called main exported calc_te function used directly.","code":""},{"path":"/reference/calculate_te_bootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Triage Effectiveness with Bootstrap — calculate_te_bootstrap","title":"Calculate Triage Effectiveness with Bootstrap — calculate_te_bootstrap","text":"Calculate Triage Effectiveness Bootstrap","code":""},{"path":"/reference/calculate_te_bootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Triage Effectiveness with Bootstrap — calculate_te_bootstrap","text":"","code":"calculate_te_bootstrap(   df,   bootstrap_params,   n_workers,   subgroup,   var1,   var2,   min_loset_warning,   seed )"},{"path":"/reference/calculate_te_bootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Triage Effectiveness with Bootstrap — calculate_te_bootstrap","text":"df Data frame containing patient data bootstrap_params List bootstrap parameters n_workers Number workers parallel processing subgroup Optional list subgroup analysis var1 Optional string first comparison variable var2 Optional string second comparison variable min_loset_warning sent onward check valid amount loset cases exists seed Seed reproducible results","code":""},{"path":"/reference/calculate_te_bootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Triage Effectiveness with Bootstrap — calculate_te_bootstrap","text":"List containing metrics, distributions, convergence information","code":""},{"path":"/reference/calculate_te_bootstrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Triage Effectiveness with Bootstrap — calculate_te_bootstrap","text":"Performs bootstrap analysis TE metrics parallel processing progress tracking.","code":""},{"path":"/reference/calculate_te_segment_bootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Triage Effectiveness with Segment Bootstrap — calculate_te_segment_bootstrap","title":"Calculate Triage Effectiveness with Segment Bootstrap — calculate_te_segment_bootstrap","text":"Calculate Triage Effectiveness Segment Bootstrap","code":""},{"path":"/reference/calculate_te_segment_bootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Triage Effectiveness with Segment Bootstrap — calculate_te_segment_bootstrap","text":"","code":"calculate_te_segment_bootstrap(   df,   bootstrap_params,   n_workers,   subgroup,   var1,   var2,   min_loset_warning,   seed )"},{"path":"/reference/calculate_te_segment_bootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Triage Effectiveness with Segment Bootstrap — calculate_te_segment_bootstrap","text":"df Data frame containing patient data bootstrap_params List bootstrap parameters n_workers Number workers parallel processing subgroup Optional list subgroup analysis var1 Optional string first comparison variable var2 Optional string second comparison variable min_loset_warning Minimum number LOSET cases warning issued seed Seed reproducible results","code":""},{"path":"/reference/calculate_te_segment_bootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Triage Effectiveness with Segment Bootstrap — calculate_te_segment_bootstrap","text":"List containing metrics, distributions, method information","code":""},{"path":"/reference/calculate_te_segment_bootstrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Triage Effectiveness with Segment Bootstrap — calculate_te_segment_bootstrap","text":"Performs segment-based bootstrap analysis TE metrics, entire queue segments resampled rather individual patients.","code":""},{"path":"/reference/calculate_unit_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Unit-Level TE Metrics — calculate_unit_metrics","title":"Calculate Unit-Level TE Metrics — calculate_unit_metrics","text":"Calculate Unit-Level TE Metrics","code":""},{"path":"/reference/calculate_unit_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Unit-Level TE Metrics — calculate_unit_metrics","text":"","code":"calculate_unit_metrics(grouping)"},{"path":"/reference/calculate_unit_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Unit-Level TE Metrics — calculate_unit_metrics","text":"grouping Grouped data frame including unit comparison variables","code":""},{"path":"/reference/calculate_unit_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Unit-Level TE Metrics — calculate_unit_metrics","text":"Tibble unit-level TE metrics","code":""},{"path":"/reference/calculate_unit_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Unit-Level TE Metrics — calculate_unit_metrics","text":"Calculates unit-level metrics including: Patient counts LOSET prevalence Mean waiting times OTE, TTE, BTTE metrics Sensitivity specificity","code":""},{"path":"/reference/cleanup_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Clean Up Parallel Processing Environment — cleanup_parallel","title":"Clean Up Parallel Processing Environment — cleanup_parallel","text":"Resets parallel processing environment sequential processing. called parallel processing complete package unload.","code":""},{"path":"/reference/cleanup_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clean Up Parallel Processing Environment — cleanup_parallel","text":"","code":"cleanup_parallel()"},{"path":"/reference/combine_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine Base Results with Bootstrap Results — combine_results","title":"Combine Base Results with Bootstrap Results — combine_results","text":"Combine Base Results Bootstrap Results","code":""},{"path":"/reference/combine_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine Base Results with Bootstrap Results — combine_results","text":"","code":"combine_results(base_results, bootstrap_results, var1, var2, subgroup)"},{"path":"/reference/combine_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine Base Results with Bootstrap Results — combine_results","text":"base_results Tibble base TE calculations bootstrap_results List containing bootstrap metrics distributions var1 applied, var1 added. var2 applied, var2 added. subgroup applied, subgroup chain added.","code":""},{"path":"/reference/combine_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine Base Results with Bootstrap Results — combine_results","text":"List combined results metadata","code":""},{"path":"/reference/combine_results.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Combine Base Results with Bootstrap Results — combine_results","text":"Merges base calculations bootstrap results creates metadata calculation process.","code":""},{"path":"/reference/combine_rte_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine RTE Base Results with Bootstrap Results — combine_rte_results","title":"Combine RTE Base Results with Bootstrap Results — combine_rte_results","text":"Combine RTE Base Results Bootstrap Results","code":""},{"path":"/reference/combine_rte_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine RTE Base Results with Bootstrap Results — combine_rte_results","text":"","code":"combine_rte_results(base_results, bootstrap_metrics)"},{"path":"/reference/combine_rte_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine RTE Base Results with Bootstrap Results — combine_rte_results","text":"base_results Tibble base RTE calculations bootstrap_metrics Tibble bootstrap metrics","code":""},{"path":"/reference/combine_rte_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine RTE Base Results with Bootstrap Results — combine_rte_results","text":"Combined results tibble","code":""},{"path":"/reference/combine_rte_results.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Combine RTE Base Results with Bootstrap Results — combine_rte_results","text":"Merges direct calculation results bootstrap metrics.","code":""},{"path":"/reference/create_batches.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Batches from Segments — create_batches","title":"Create Batches from Segments — create_batches","text":"function organizes segments patient data batches approximately equal size. Batching used distribute workload evenly across available processing cores efficient parallel computation.","code":""},{"path":"/reference/create_batches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Batches from Segments — create_batches","text":"","code":"create_batches(segments, n_batches)"},{"path":"/reference/create_batches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Batches from Segments — create_batches","text":"segments list data frame segments created create_segments function. n_batches Integer. number batches create, typically equal number available cores.","code":""},{"path":"/reference/create_batches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Batches from Segments — create_batches","text":"list batches, batch contains one segments.","code":""},{"path":"/reference/create_batches.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Batches from Segments — create_batches","text":"function aims create batches roughly equal total size (terms number patients) ensure balanced workload distribution parallel processing. approach optimizes use computational resources simulation.","code":""},{"path":"/reference/create_grouping.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Grouped Data Structure for TE Calculations — create_grouping","title":"Create Grouped Data Structure for TE Calculations — create_grouping","text":"Create Grouped Data Structure TE Calculations","code":""},{"path":"/reference/create_grouping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Grouped Data Structure for TE Calculations — create_grouping","text":"","code":"create_grouping(df, subgroup = NULL, var1 = NULL, var2 = NULL)"},{"path":"/reference/create_grouping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Grouped Data Structure for TE Calculations — create_grouping","text":"df Data frame containing patient data subgroup Optional list subgroup analysis var1 Optional string first comparison variable var2 Optional string second comparison variable","code":""},{"path":"/reference/create_grouping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Grouped Data Structure for TE Calculations — create_grouping","text":"grouped dataframe appropriate grouping structure TE calculations","code":""},{"path":"/reference/create_grouping.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Grouped Data Structure for TE Calculations — create_grouping","text":"Creates grouped structure based input parameters: Basic: Groups unit Subgroup: Filters subgroup criteria, groups unit Single comparison: Groups unit one comparison variable Double comparison: Groups unit two comparison variables","code":""},{"path":"/reference/create_overall_grouping.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Overall Grouping Structure — create_overall_grouping","title":"Create Overall Grouping Structure — create_overall_grouping","text":"Create Overall Grouping Structure","code":""},{"path":"/reference/create_overall_grouping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Overall Grouping Structure — create_overall_grouping","text":"","code":"create_overall_grouping(results, subgroup = NULL, var1 = NULL, var2 = NULL)"},{"path":"/reference/create_overall_grouping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Overall Grouping Structure — create_overall_grouping","text":"results Unit-level results subgroup Optional list subgroup analysis var1 Optional string first comparison variable var2 Optional string second comparison variable","code":""},{"path":"/reference/create_overall_grouping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Overall Grouping Structure — create_overall_grouping","text":"grouped data frame overall calculations","code":""},{"path":"/reference/create_overall_grouping.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Overall Grouping Structure — create_overall_grouping","text":"Creates appropriate grouping structure calculating overall metrics based analysis type (basic, subgroup, comparison variables).","code":""},{"path":"/reference/create_segments.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Segment Identifiers in Patient Data — create_segments","title":"Create Segment Identifiers in Patient Data — create_segments","text":"function adds segment identifier column input patient data based continuous queue periods. segment represents period queue starts 0 ends 0, allowing independent processing time periods.","code":""},{"path":"/reference/create_segments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Segment Identifiers in Patient Data — create_segments","text":"","code":"create_segments(df, n_workers = 1)"},{"path":"/reference/create_segments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Segment Identifiers in Patient Data — create_segments","text":"df data frame containing patient data, including ID, unit, arrival times, resolve times. n_workers Integer. Number cores use parallel processing. Default (detectCores() - 1).","code":""},{"path":"/reference/create_segments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Segment Identifiers in Patient Data — create_segments","text":"data frame additional 'segment' column identifies continuous queue segments.","code":""},{"path":"/reference/create_segments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Segment Identifiers in Patient Data — create_segments","text":"function identifies periods queue size goes 0 1, marking start new segment. assigns segment IDs patients based boundaries, can used grouped processing parallel simulations. segmentation crucial maintaining chronological integrity enabling parallelization.","code":""},{"path":"/reference/dot-onAttach.html","id":null,"dir":"Reference","previous_headings":"","what":"Package Attachment Hook — .onAttach","title":"Package Attachment Hook — .onAttach","text":"Displays startup messages package attached. Shows version information parallel processing configuration.","code":""},{"path":"/reference/dot-onAttach.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Package Attachment Hook — .onAttach","text":"","code":".onAttach(libname, pkgname)"},{"path":"/reference/dot-onAttach.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Package Attachment Hook — .onAttach","text":"libname Character string giving library package installed pkgname Character string giving name package","code":""},{"path":"/reference/dot-onLoad.html","id":null,"dir":"Reference","previous_headings":"","what":"Package Loading Hook — .onLoad","title":"Package Loading Hook — .onLoad","text":"Initializes package options environment package loaded. Sets default values cores, backend, progress reporting, logging.","code":""},{"path":"/reference/dot-onLoad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Package Loading Hook — .onLoad","text":"","code":".onLoad(libname, pkgname)"},{"path":"/reference/dot-onLoad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Package Loading Hook — .onLoad","text":"libname Character string giving library package installed pkgname Character string giving name package","code":""},{"path":"/reference/dot-onUnload.html","id":null,"dir":"Reference","previous_headings":"","what":"Package Unload Hook — .onUnload","title":"Package Unload Hook — .onUnload","text":"Performs cleanup operations package unloaded. Ensures proper cleanup parallel processing package environment.","code":""},{"path":"/reference/dot-onUnload.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Package Unload Hook — .onUnload","text":"","code":".onUnload(libpath)"},{"path":"/reference/dot-onUnload.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Package Unload Hook — .onUnload","text":"libpath Character string giving library package installed","code":""},{"path":"/reference/get_optimal_backend.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine Optimal Parallel Backend — get_optimal_backend","title":"Determine Optimal Parallel Backend — get_optimal_backend","text":"Determines suitable parallel processing backend based system environment. Returns \"multisession\" RStudio environments Windows systems, \"multicore\" systems available.","code":""},{"path":"/reference/get_optimal_backend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine Optimal Parallel Backend — get_optimal_backend","text":"","code":"get_optimal_backend()"},{"path":"/reference/get_optimal_backend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine Optimal Parallel Backend — get_optimal_backend","text":"Character string specifying optimal backend (\"multisession\" \"multicore\")","code":""},{"path":"/reference/init.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize the Data and Settings — init","title":"Initialize the Data and Settings — init","text":"function initializes data frame settings triage efficacy calculations. ensures required columns present, validates data, casts variables appropriate types, adds calculated fields. 'start' 'stop' provided, default earliest arrival time latest resolve time data frame, respectively. also logs success error messages based specified logging level.","code":""},{"path":"/reference/init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize the Data and Settings — init","text":"","code":"init(   Df,   start = NULL,   stop = NULL,   Logg_level = 0,   time_critical_prio = c(1, 2) )"},{"path":"/reference/init.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialize the Data and Settings — init","text":"Df Data frame containing data. start Optional. start datetime calculating arrival resolve minutes. provided, defaults earliest arrival time data frame. stop Optional. stop datetime calculating arrival resolve minutes. provided, defaults latest resolve time data frame. Logg_level integer indicating logging level. 0 logs errors, 1 logs successes well. time_critical_prio 1 priorities, specified within c() counted time critical calculated sensitivity/specificity.","code":""},{"path":"/reference/init.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialize the Data and Settings — init","text":"data frame validated modified fields.","code":""},{"path":"/reference/init.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Initialize the Data and Settings — init","text":"note \"fix\" datetimes within function due error R/lubridate treats hms 00:00:00 non existing, means later cast just date wich returns NA ymd_hms casting.","code":""},{"path":"/reference/init.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Initialize the Data and Settings — init","text":"","code":"if (FALSE) { # \\dontrun{ init(Df = your_data_frame, start = start_date, stop = stop_date) init(Df = your_data_frame)  # Automatically uses the earliest and latest times in the data frame } # }"},{"path":"/reference/init_progressr.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize Progress Reporting Handlers — init_progressr","title":"Initialize Progress Reporting Handlers — init_progressr","text":"Sets progress reporting handlers progress reporting enabled package options.","code":""},{"path":"/reference/init_progressr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize Progress Reporting Handlers — init_progressr","text":"","code":"init_progressr()"},{"path":"/reference/plot.te_convergence.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for TE Convergence Results — plot.te_convergence","title":"Plot Method for TE Convergence Results — plot.te_convergence","text":"Alternative method display convergence analysis results. Functions identically print.te_convergence consistency output display.","code":""},{"path":"/reference/plot.te_convergence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for TE Convergence Results — plot.te_convergence","text":"","code":"# S3 method for class 'te_convergence' plot(x, ...)"},{"path":"/reference/plot.te_convergence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for TE Convergence Results — plot.te_convergence","text":"x te_convergence object containing convergence analysis results ... Additional arguments passed plot (currently used)","code":""},{"path":"/reference/plot.te_convergence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for TE Convergence Results — plot.te_convergence","text":"Invisibly returns input object","code":""},{"path":"/reference/plot_rte_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot RTE Distribution — plot_rte_distribution","title":"Plot RTE Distribution — plot_rte_distribution","text":"Creates histogram visualization RTE values statistical annotations. function filters valid time-critical patients, removes extreme outliers, can display normality test results basic statistics.","code":""},{"path":"/reference/plot_rte_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot RTE Distribution — plot_rte_distribution","text":"","code":"plot_rte_distribution(   data,   metric = \"observed_RTE\",   cutoff_percentile = 0.01,   bin_width = 0.1,   include_stats = TRUE,   color = \"#D4AF37\",   facet_by_unit = FALSE )"},{"path":"/reference/plot_rte_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot RTE Distribution — plot_rte_distribution","text":"data Data frame containing RTE values metric Character. RTE metric plot: \"observed_RTE\", \"theoretical_RTE\", \"binary_theoretical_RTE\". Default \"observed_RTE\". cutoff_percentile Numeric. Percentile cutoff removing extreme outliers. Default 0.01 (removes lowest 1%). bin_width Numeric. Width histogram bins. Default 0.1. include_stats Logical. Whether display statistical annotations. Default TRUE. color Character. Color histogram bars. Default \"#D4AF37\" (gold). facet_by_unit Logical. Default FALSE. TRUE, creates separate facet panels unit, allowing comparison RTE distributions across different units.","code":""},{"path":"/reference/plot_rte_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot RTE Distribution — plot_rte_distribution","text":"ggplot object","code":""},{"path":"/reference/plot_te.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Triage Effectiveness Plot — plot_te","title":"Create a Triage Effectiveness Plot — plot_te","text":"function generates plot visualize Triage Effectiveness (TE) metrics. can display Theoretical Triage Effectiveness (TTE) Observed Triage Effectiveness (OTE) different units, optional grouping variables variability intervals.","code":""},{"path":"/reference/plot_te.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Triage Effectiveness Plot — plot_te","text":"","code":"plot_te(   data,   title = \"Triage Effectiveness Plot\",   show_tte = NULL,   show_ote = NULL,   show_var = NULL,   var_alpha = 0.5,   dumbell_width = 1,   var_width = 1.5,   var_end_width = 1,   var_end_height = 0.1,   label_style = \"half\",   min_x = NULL,   ci_vars_override = NULL )"},{"path":"/reference/plot_te.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Triage Effectiveness Plot — plot_te","text":"data data frame containing following columns: unit: Factor character vector unit names tte_te: Numeric vector Theoretical Triage Effectiveness values ote_te: Numeric vector Observed Triage Effectiveness values boot_tte_var_lower: Optional. Lower variability value TTE boot_tte_var_upper: Optional. Upper variability value TTE boot_ote_var_lower: Optional. Lower variability value OTE boot_ote_var_upper: Optional. Upper variability value OTE title Character string plot title. Default \"Triage Effectiveness Plot\". show_tte Logical, whether display TTE values. Default NULL. show TTE data. show_ote Logical, whether display OTE values. Default NULL. show OTE data. show_var Logical, whether display variability intervals. Default null. show variability data supplied. var_alpha Numeric 0 1, specifying transparency variability interval lines. Default 0.5. dumbell_width Numeric, specifying width line connecting TTE OTE points. Default 1. Note since line horizontal, \"width\" represents thickness. var_width Numeric, specifying width main variability interval lines - vertical line end variability span. Default 1.5. var_end_width Numeric, specifying width (thickness) variability interval end lines. Default 1. var_end_height Numeric, specifying height variability interval end lines offset center. Default 0.05. label_style categorical, valid inputs - \"none\", \"small\", \"full\" & \"half\". Decides style label TTE/OTE rights side graph. Default half witch nets label style : \"Theoretical TE\". Small: \"TTE\", Full: \"Theoretical Triage Effectiveness\". min_x Percentual value minimum value plot stretch . Default null uses min value data rounded next 10%. Useful set several plots one negative values keep aspect ratio. ci_vars_override Character string. Explicitly specify CI variables use: \"parametric\", \"nonparametric\", \"boot\". NULL (default), uses recommended variables metadata based calculation method normality tests.","code":""},{"path":"/reference/plot_te.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Triage Effectiveness Plot — plot_te","text":"ggplot object representing Triage Effectiveness plot.","code":""},{"path":"/reference/plot_te.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Triage Effectiveness Plot — plot_te","text":"","code":"if (FALSE) { # \\dontrun{ data <- data.frame(   unit = c(\"Unit A\", \"Unit B\", \"Unit C\"),   tte_te = c(0.6, 0.7, 0.5),   ote_te = c(0.65, 0.75, 0.55),   boot_tte_var_lower = c(0.55, 0.65, 0.45),   boot_tte_var_upper = c(0.65, 0.75, 0.55),   boot_ote_var_lower = c(0.60, 0.70, 0.50),   boot_ote_var_upper = c(0.70, 0.80, 0.60) ) plot_te(data, show_var = TRUE) } # }"},{"path":"/reference/plot_te_heatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Triage Effectiveness Heatmap — plot_te_heatmap","title":"Plot Triage Effectiveness Heatmap — plot_te_heatmap","text":"Creates heatmap visualizations Triage Effectiveness (TE) data. Can display either single heatmap multiple heatmaps showing alternative calculations.","code":""},{"path":"/reference/plot_te_heatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Triage Effectiveness Heatmap — plot_te_heatmap","text":"","code":"plot_te_heatmap(   data,   show_labels = TRUE,   show_alt_calc = FALSE,   normalize = FALSE,   color_scheme = \"oceansky\",   title = \"Triage Effectiveness Heatmap\",   axis_step_size = NULL )"},{"path":"/reference/plot_te_heatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Triage Effectiveness Heatmap — plot_te_heatmap","text":"data Tibble containing TE data columns: sensitivity: Sensitivity values specificity: Specificity values te: TE values calc_method: (Optional) Indicates whether data uses \"wte\" \"rte\" calculations Additional columns alternative calculations available show_labels Logical. TRUE, displays numeric values heatmap. Default TRUE. show_alt_calc Logical. TRUE, displays multiple heatmaps alternative calculations. Default FALSE. Note sim_heat_alt needs run relevant variables . normalize Logical. TRUE, normalizes values 0-100 scale. Ignored show_alt_calc=TRUE. Default FALSE. color_scheme Character. Either \"triage\", \"oceansky\", \"blueorange\" \"thermalsafe\". triage alternative color blind safe included since mimics classic triage colors title Character. Title plot. Default \"Triage Effectiveness Heatmap\". axis_step_size Numeric NULL. Override step size axis labels (e.g., 0.1 10% steps). NULL (default), automatically determines optimal step size based data resolution, minimum 0.05 (5%). Automatic detection selects 25% steps data 25% resolution, 10% steps data 10% resolution, 5% steps finer resolutions.","code":""},{"path":"/reference/plot_te_heatmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Triage Effectiveness Heatmap — plot_te_heatmap","text":"ggplot object (single heatmap) list patchwork objects (multiple heatmaps)","code":""},{"path":"/reference/print.calc_te.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for Triage Effectiveness Results — print.calc_te","title":"Print Method for Triage Effectiveness Results — print.calc_te","text":"Formats displays triage effectiveness analysis results readable format. Shows metrics analysis group including sample sizes, classification metrics, triage effectiveness values. bootstrap analysis performed, also displays confidence intervals.","code":""},{"path":"/reference/print.calc_te.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for Triage Effectiveness Results — print.calc_te","text":"","code":"# S3 method for class 'calc_te' print(x, ...)"},{"path":"/reference/print.calc_te.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for Triage Effectiveness Results — print.calc_te","text":"x calc_te object containing: results: Tibble TE metrics metadata: List calculation parameters bootstrap_distributions: Optional bootstrap results ... Additional arguments passed print (currently used)","code":""},{"path":"/reference/print.calc_te.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print Method for Triage Effectiveness Results — print.calc_te","text":"output organized sections: Results group showing: Total patients LOSET prevalence Classification metrics (sensitivity, specificity) Triage Effectiveness metrics (OTE, TTE, OTG) Bootstrap variation intervals (available) Computation information including: Calculation method (bootstrap direct) Number iterations (bootstrap) Sample percentage (bootstrap) Calculation timestamp","code":""},{"path":"/reference/print.te_convergence.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for TE Convergence Results — print.te_convergence","title":"Print Method for TE Convergence Results — print.te_convergence","text":"Displays convergence analysis results, showing key metadata diagnostic plots assessing bootstrap convergence stability.","code":""},{"path":"/reference/print.te_convergence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for TE Convergence Results — print.te_convergence","text":"","code":"# S3 method for class 'te_convergence' print(x, ...)"},{"path":"/reference/print.te_convergence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for TE Convergence Results — print.te_convergence","text":"x te_convergence object containing convergence analysis results ... Additional arguments passed print (currently used)","code":""},{"path":"/reference/print.te_convergence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for TE Convergence Results — print.te_convergence","text":"Invisibly returns input object","code":""},{"path":"/reference/run_simulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Simulation on a Single Segment — run_simulation","title":"Run Simulation on a Single Segment — run_simulation","text":"function performs core simulation logic calculating Theoretical Triage Efficacy (TTE) Binary Theoretical Triage Efficacy (BTTE) single segment patient data.","code":""},{"path":"/reference/run_simulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Simulation on a Single Segment — run_simulation","text":"","code":"run_simulation(segment, tte = TRUE, btte = FALSE)"},{"path":"/reference/run_simulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Simulation on a Single Segment — run_simulation","text":"segment data.table representing segment patient data. tte Logical. TRUE, calculates Theoretical Triage Efficacy (TTE). btte Logical. TRUE, calculates Binary Theoretical Triage Efficacy (BTTE).","code":""},{"path":"/reference/run_simulation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Simulation on a Single Segment — run_simulation","text":"data.table calculated wait times resolve times.","code":""},{"path":"/reference/run_simulation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run Simulation on a Single Segment — run_simulation","text":"function simulates patient flow healthcare system deterministic manner, strictly adhering priority order wait time within priority. optimized performance using data.table operations. used sim_te sim_heat.","code":""},{"path":"/reference/sem_malmo_synth.html","id":null,"dir":"Reference","previous_headings":"","what":"Synthetic Emergency Department Data from Malmö Hospital — sem_malmo_synth","title":"Synthetic Emergency Department Data from Malmö Hospital — sem_malmo_synth","text":"synthetic dataset generated based statistical properties ED visits Malmö Hospital Skåne Emergency Medicine (SEM) database. Generated using synthpop methodology, dataset mimics real patterns containing actual patient data.","code":""},{"path":"/reference/sem_malmo_synth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Synthetic Emergency Department Data from Malmö Hospital — sem_malmo_synth","text":"","code":"sem_malmo_synth"},{"path":"/reference/sem_malmo_synth.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Synthetic Emergency Department Data from Malmö Hospital — sem_malmo_synth","text":"data frame 124,311 observations 16 variables: priority Factor 4 levels (1-4) representing triage priority, 1 highest priority ambulance Logical indicating patient arrived ambulance unit Factor 3 levels: \"medical\", \"orthopedics\", \"surgical\" indicating treating specialty chief_complaint Factor 68 levels representing main reason ED visit age_at_arrival Numeric age patient time arrival male Logical indicating patient gender (TRUE male) planed_return_visit Logical indicating visit planned return referral Logical indicating patient referred ED exit_info Factor 4 levels: \"Admitted\", \"Died\", \"Home\", \"Unknown\" indicating ED visit outcome death_days Numeric, days death applicable, NA otherwise ward Factor 12 levels indicating receiving type ward admitted patients loset Logical indicating case time-critical according LOSET criteria arrival_at_hospital POSIXct timestamp arrival hospital exit_ed POSIXct timestamp exit ED resolve POSIXct timestamp first physician contact arrival POSIXct timestamp triage assessment","code":""},{"path":"/reference/sem_malmo_synth.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Synthetic Emergency Department Data from Malmö Hospital — sem_malmo_synth","text":"Based statistical properties Skåne Emergency Medicine (SEM) database. Reference: Ekelund, U., et al. (2024). Skåne Emergency Medicine (SEM) cohort. Scandinavian Journal Trauma Resuscitation Emergency Medicine, 32(1). doi: https://doi.org/10.1186/s13049-024-01206-0","code":""},{"path":"/reference/sem_malmo_synth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Synthetic Emergency Department Data from Malmö Hospital — sem_malmo_synth","text":"synthetic dataset based ED visits 2017-2018 Malmö Hospital. preserves statistical relationships patterns original data containing real patient information. dataset includes adult patients (age >= 18) medical, surgical, orthopedic complaints. However data similar SEM identical. Differences exists waiting times priorities similar enough experimentaiton trieff statistical package feasible. dataset used running tests trieff statistical package build. Time variables follow sequence: arrival_at_hospital <= arrival (triage) <= resolve (physician) <= exit_ed","code":""},{"path":"/reference/setup_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Setup Parallel Processing Environment — setup_parallel","title":"Setup Parallel Processing Environment — setup_parallel","text":"Configures parallel processing environment using future package. Automatically selects sets appropriate backend based system environment user settings. using multisession, uses callr backend better cleanup behavior forced termination.","code":""},{"path":"/reference/setup_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setup Parallel Processing Environment — setup_parallel","text":"","code":"setup_parallel(n_workers = getOption(\"trieff.cores\"))"},{"path":"/reference/setup_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setup Parallel Processing Environment — setup_parallel","text":"n_workers Integer. Number cores use parallel processing. Defaults value set trieff.cores option.","code":""},{"path":"/reference/setup_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setup Parallel Processing Environment — setup_parallel","text":"Character string indicating backend chosen","code":""},{"path":"/reference/sim_heat.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Triage Effectiveness over different levels of sensitivity/specificity. — sim_heat","title":"Simulate Triage Effectiveness over different levels of sensitivity/specificity. — sim_heat","text":"Efficiently generates heatmap analyzing relationship sensitivity, specificity, Triage Effectiveness (TE). function optimizes performance : Processing segments containing time-critical (LOSET) cases Parallelizing across sensitivity/specificity combinations","code":""},{"path":"/reference/sim_heat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Triage Effectiveness over different levels of sensitivity/specificity. — sim_heat","text":"","code":"sim_heat(   df,   step_size,   n_workers = detectCores() - 1,   pos_values_only = FALSE,   n_loset = NULL,   seed = NULL,   calc_method = \"rte\",   include_dataframes = FALSE )"},{"path":"/reference/sim_heat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Triage Effectiveness over different levels of sensitivity/specificity. — sim_heat","text":"df data frame containing patient data (must initialized init()) step_size Numeric. step size sensitivity specificity values. Must one : 25, 10, 5, 2.5, 1. representing percentual step sensitivity/specificity taken. n_workers Integer. Number cores use parallel processing. Default (detectCores() - 1). pos_values_only Logical. TRUE, includes combinations sensitivity + specificity >= 1. Default FALSE. n_loset Integer, least number LOSET cases data frame. duplicate data reach . Can get LOSET cases. seed Seed reproducible heat maps (default: null - seed) calc_method String. Method use calculating TE: \"wte\" waiting time-based TE, \"rte\" rank-based TE (default). include_dataframes Logical. TRUE, includes complete simulation data frames output detailed analysis. Default FALSE minimize memory usage.","code":""},{"path":"/reference/sim_heat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Triage Effectiveness over different levels of sensitivity/specificity. — sim_heat","text":"Tibble sensitivity, specificity TE values","code":""},{"path":"/reference/sim_heat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Triage Effectiveness over different levels of sensitivity/specificity. — sim_heat","text":"function processes data key steps: Pre-calculation: Computes overall mean waiting time TE calculations Identifies segments containing LOSET cases Creates sensitivity/specificity combinations based step_size Parallel Processing: Processes combination independently across workers combination: Scholastically applies priority assignment based sensitivity/specificity Simulates queue processing step Calculates resulting (binary) TE value Progress Tracking: Updates progress step Performance considerations: Large step_sizes (e.g., 25) suitable initial exploration Smaller step_sizes provide detailed analysis increase computation time Processing time increases dataset size number combinations","code":""},{"path":"/reference/sim_heat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Triage Effectiveness over different levels of sensitivity/specificity. — sim_heat","text":"","code":"if (FALSE) { # \\dontrun{ # Basic usage results <- sim_heat(patient_data, step_size = 10)  # Only positive values results <- sim_heat(patient_data,                     step_size = 10,                     pos_values_only = TRUE)  # Adjust worker count results <- sim_heat(patient_data,                     step_size = 10,                     n_workers = 4)  # Include simulation data frames results <- sim_heat(patient_data,                     step_size = 10,                     include_dataframes = TRUE) } # }"},{"path":"/reference/sim_heat_alt.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Triage Effectiveness including alternative calculations for methodology research — sim_heat_alt","title":"Simulate Triage Effectiveness including alternative calculations for methodology research — sim_heat_alt","text":"Performs simulations analyze Triage Effectiveness (TE) varies different combinations sensitivity specificity. function supports waiting time-based TE (WTE) rank-based TE (RTE) calculations, options alternative transformations explore methodological aspects triage performance measurement.","code":""},{"path":"/reference/sim_heat_alt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Triage Effectiveness including alternative calculations for methodology research — sim_heat_alt","text":"","code":"sim_heat_alt(   df,   step_size,   n_workers = detectCores() - 1,   include_dataframes = FALSE,   alt_calc = FALSE,   pos_values_only = FALSE,   n_loset = NULL,   seed = NULL,   calc_method = \"rte\" )"},{"path":"/reference/sim_heat_alt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Triage Effectiveness including alternative calculations for methodology research — sim_heat_alt","text":"df Data frame containing patient data (must initialized init()) step_size Numeric. step size sensitivity specificity values. Must one : 25, 10, 5, 2.5, 1. n_workers Integer. Number cores use parallel processing. Default (detectCores() - 1). include_dataframes Logical. TRUE, includes complete simulation data frames output detailed analysis. Default FALSE minimize memory usage. alt_calc Logical. TRUE, calculates alternative TE metrics using transformations appropriate calculation method. Default FALSE. pos_values_only Logical. TRUE, includes combinations sensitivity + specificity >= 1. Default FALSE. n_loset Integer. Minimum number LOSET cases desired. duplicate data reach threshold. Default NULL (duplication). seed Integer. Seed reproducible heatmaps. Default NULL (seed). calc_method String. Method use calculating TE: \"wte\" waiting time-based TE, \"rte\" rank-based TE (default).","code":""},{"path":"/reference/sim_heat_alt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Triage Effectiveness including alternative calculations for methodology research — sim_heat_alt","text":"tibble containing: sensitivity: Sensitivity value simulation specificity: Specificity value simulation te: Standard TE value (WTE RTE based calc_method) alt_calc=TRUE calc_method=\"wte\": te_cube: TE cube root normalization waiting times te_log: TE log normalization waiting times te_median_local: TE using local median-based calculation te_median_global: TE using global median-based calculation Additional columns raw metrics (mean_all, cube_all, etc.) alt_calc=TRUE calc_method=\"rte\": te_cube: RTE cube root transformation te_log: RTE signed logarithmic transformation Additional raw metrics appropriate sim_data: (include_dataframes=TRUE) Complete simulation data frames","code":""},{"path":"/reference/sim_heat_alt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Triage Effectiveness including alternative calculations for methodology research — sim_heat_alt","text":"function performs key steps: Creates combinations sensitivity/specificity values based step_size Identifies segments containing time-critical (LOSET) cases Processes combination parallel: Assigns priorities based sensitivity/specificity Simulates queue processing Calculates TE metrics (WTE RTE based calc_method) Applies alternative calculations requested Returns combined results tibble format WTE alternative calculations (alt_calc=TRUE calc_method=\"wte\"): Cube root: Normalizes wait times using cube root transformation Log: Normalizes wait times using log transformation Median: Uses median instead mean central tendency RTE alternative calculations (alt_calc=TRUE calc_method=\"rte\"): Cube root: Applies cube root transformation RTE values (preserves sign) Signed log: Applies sign-preserving log transformation: sign(x) * log(1 + abs(x)) Performance considerations: Large step_sizes (e.g., 25) suitable initial exploration Smaller step_sizes provide detailed analysis increase computation time Setting include_dataframes=TRUE significantly increases memory usage Processing time increases dataset size number combinations","code":""},{"path":"/reference/sim_te.html","id":null,"dir":"Reference","previous_headings":"","what":"Triage Efficacy Simulation — sim_te","title":"Triage Efficacy Simulation — sim_te","text":"function performs optimized simulation calculate Triage Efficacy (TE) metrics simulating segments containing time-critical (LOSET-positive) cases. segments without LOSET cases, uses observed wait times directly, since segments affect TE calculations. optimization significantly reduces computation time maintaining identical TE results compared full simulation.","code":""},{"path":"/reference/sim_te.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Triage Efficacy Simulation — sim_te","text":"","code":"sim_te(df, tte = TRUE, btte = FALSE, n_workers = 1)"},{"path":"/reference/sim_te.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Triage Efficacy Simulation — sim_te","text":"df data frame containing patient data, including (note theese variables created init()): id: Unique patient identifier arrival_minute: Minutes since start study period patient arrival resolve_minute: Minutes since start patient sees physician priority: Original triage priority priority_binary: Binary priority (typically 1 high, 2 low) loset: Logical indicating patient time-critical per LOSET criteria observed_wait_time: Actual waiting time minutes tte Logical. TRUE, calculates Theoretical Triage Efficacy (TTE). Default TRUE. btte Logical. TRUE, calculates Binary Theoretical Triage Efficacy (BTTE). Default FALSE. n_workers Integer. Number cores use parallel processing. Default 1.","code":""},{"path":"/reference/sim_te.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Triage Efficacy Simulation — sim_te","text":"data frame original patient data additional columns: theoretical_wait_time: Simulated wait time based original priorities (tte=TRUE) binary_theoretical_wait_time: Simulated wait time based binary priorities (btte=TRUE)","code":""},{"path":"/reference/sim_te.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Triage Efficacy Simulation — sim_te","text":"function simulates patients processed strictly following assigned priority levels. simulation operates : Identifying continuous queue segments (periods queue size goes 0 0) Determining segments contain time-critical (LOSET) cases Simulating segments containing LOSET cases using non-preemptive approach: physician contact becomes available time slot Patients queued priority arrival time Wait times calculated slot assignment segments without LOSET cases, observed wait times retained theoretical wait times. valid : TE calculations depend LOSET patient wait times relative mean_all Using observed times non-LOSET segments maintains correct mean_all waiting times non-LOSET patients affect TE calculations simulation ensures : Within simulated segment, patients seen strictly order priority Within priority level, patients seen order arrival post-triage priority changes occur","code":""},{"path":[]},{"path":"/reference/sim_te.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Triage Efficacy Simulation — sim_te","text":"","code":"if (FALSE) { # \\dontrun{ # Basic usage with default settings results <- sim_te_fast(patient_data)  # Calculate both TTE and BTTE results <- sim_te_fast(patient_data, tte = TRUE, btte = TRUE) } # }"},{"path":"/reference/sim_te_alt.html","id":null,"dir":"Reference","previous_headings":"","what":"Full Triage Effectiveness Simulation for Research — sim_te_alt","title":"Full Triage Effectiveness Simulation for Research — sim_te_alt","text":"Performs complete simulation emergency department patient flow, calculating theoretical wait times patients regardless time-critical status. function designed research purposes complete queue behavior analysis needed, computationally intensive standard sim_te function.","code":""},{"path":"/reference/sim_te_alt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Full Triage Effectiveness Simulation for Research — sim_te_alt","text":"","code":"sim_te_alt(df, tte = TRUE, btte = FALSE, n_workers = 1)"},{"path":"/reference/sim_te_alt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Full Triage Effectiveness Simulation for Research — sim_te_alt","text":"df data frame containing patient data, including: id: Unique patient identifier arrival_minute: Minutes since start study period patient arrival resolve_minute: Minutes since start patient sees physician priority: Original triage priority priority_binary: Binary priority (typically 1 high, 2 low) loset: Logical indicating patient time-critical per LOSET criteria observed_wait_time: Actual waiting time minutes tte Logical. TRUE, calculates Theoretical Triage Efficacy (TTE). Default TRUE. btte Logical. TRUE, calculates Binary Theoretical Triage Efficacy (BTTE). Default FALSE. n_workers Integer. Number cores use parallel processing. Default 1.","code":""},{"path":"/reference/sim_te_alt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Full Triage Effectiveness Simulation for Research — sim_te_alt","text":"data frame original patient data additional columns: theoretical_wait_time: Simulated wait time based original priorities (tte=TRUE) binary_theoretical_wait_time: Simulated wait time based binary priorities (btte=TRUE)","code":""},{"path":"/reference/sim_te_alt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Full Triage Effectiveness Simulation for Research — sim_te_alt","text":"Unlike sim_te optimizes performance focusing segments containing time-critical cases, sim_te_alt simulates waiting times patients. makes suitable research purposes : Analyzing complete queue behavior patterns Studying wait time distributions non-time-critical patients Validating simulation methodology Investigating effects different priority schemes simulation operates non-preemptive manner, treating physician contacts available time slots processing patients strictly according priority arrival order. provides complete information theoretical queue behavior, computationally intensive sim_te may necessary standard TE calculations. Note sim_te_alt calculates wait times patients, produces identical TE values sim_te since TE metrics depend wait times time-critical patients relative overall mean.","code":""},{"path":[]},{"path":"/reference/sim_te_alt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Full Triage Effectiveness Simulation for Research — sim_te_alt","text":"","code":"if (FALSE) { # \\dontrun{ # Basic usage with default settings results <- sim_te_alt(patient_data)  # Calculate both TTE and BTTE with parallel processing results <- sim_te_alt(patient_data,                       tte = TRUE,                       btte = TRUE,                       n_workers = 4) } # }"},{"path":"/reference/trieff-globals.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal package global variables — trieff-globals","title":"Internal package global variables — trieff-globals","text":"Internal package global variables","code":""},{"path":"/reference/trieff-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal package utilities and initialization — trieff-package","title":"Internal package utilities and initialization — trieff-package","text":"comprehensive toolkit analyzing evaluating triage effectiveness emergency departments contexts. package provides methods calculating theoretical observed triage effectiveness, simulating triage, visualizing results dumbell plots heatmaps.","code":""},{"path":[]},{"path":"/reference/trieff-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Internal package utilities and initialization — trieff-package","text":"Maintainer: André Johansson andre.johansson@med.lu.se (ORCID)","code":""},{"path":"/reference/validate_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Results and Generate Warnings — validate_results","title":"Validate Results and Generate Warnings — validate_results","text":"Validate Results Generate Warnings","code":""},{"path":"/reference/validate_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Results and Generate Warnings — validate_results","text":"","code":"validate_results(results, min_loset_warning)"},{"path":"/reference/validate_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Results and Generate Warnings — validate_results","text":"results Combined unit overall results min_loset_warning Least number LOSET cases exists function warn.","code":""},{"path":"/reference/validate_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Results and Generate Warnings — validate_results","text":"Invisible NULL, generates warnings issues found","code":""},{"path":"/reference/validate_results.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate Results and Generate Warnings — validate_results","text":"Performs validation checks calculated results: Low LOSET counts Extreme TE values","code":""},{"path":"/reference/validate_rte_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate RTE Results and Generate Warnings — validate_rte_results","title":"Validate RTE Results and Generate Warnings — validate_rte_results","text":"Validate RTE Results Generate Warnings","code":""},{"path":"/reference/validate_rte_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate RTE Results and Generate Warnings — validate_rte_results","text":"","code":"validate_rte_results(results, min_loset_warning, quite)"},{"path":"/reference/validate_rte_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate RTE Results and Generate Warnings — validate_rte_results","text":"results Combined unit overall results min_loset_warning Least number LOSET cases exist function warn.","code":""},{"path":"/reference/validate_rte_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate RTE Results and Generate Warnings — validate_rte_results","text":"Logical indicating non-normality detected unit","code":""},{"path":"/reference/validate_rte_results.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate RTE Results and Generate Warnings — validate_rte_results","text":"Performs validation checks calculated results: Low LOSET counts Units valid RTE measurements Potential non-normal distributions","code":""},{"path":"/reference/validate_sim_heat_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Data Structure for sim_heat Functions — validate_sim_heat_data","title":"Validate Data Structure for sim_heat Functions — validate_sim_heat_data","text":"Validate Data Structure sim_heat Functions","code":""},{"path":"/reference/validate_sim_heat_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Data Structure for sim_heat Functions — validate_sim_heat_data","text":"","code":"validate_sim_heat_data(df)"},{"path":"/reference/validate_sim_heat_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Data Structure for sim_heat Functions — validate_sim_heat_data","text":"df Data frame validate containing patient data","code":""},{"path":"/reference/validate_sim_heat_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Data Structure for sim_heat Functions — validate_sim_heat_data","text":"TRUE validation passes, otherwise throws error descriptive message","code":""},{"path":"/reference/validate_sim_heat_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate Data Structure for sim_heat Functions — validate_sim_heat_data","text":"Performs validation checks sim_heat sim_heat_alt functions including: Required column presence Column data types Initialization state Required columns: arrival_minute (numeric, added init) resolve_minute (numeric, added init) priority_binary (factor, added init) loset (logical) observed_wait_time (numeric, added init) unit (factor)","code":""},{"path":"/reference/validate_te_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Triage Effectiveness Data — validate_te_data","title":"Validate Triage Effectiveness Data — validate_te_data","text":"Validate Triage Effectiveness Data","code":""},{"path":"/reference/validate_te_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Triage Effectiveness Data — validate_te_data","text":"","code":"validate_te_data(df, subgroup = NULL, var1 = NULL, var2 = NULL)"},{"path":"/reference/validate_te_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Triage Effectiveness Data — validate_te_data","text":"df Data frame containing patient data subgroup Optional list subgroup analysis var1 Optional string first comparison variable var2 Optional string second comparison variable","code":""},{"path":"/reference/validate_te_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate Triage Effectiveness Data — validate_te_data","text":"Performs validation checks input data including: Required columns presence Data type validation Value range validation Comparison variable validity","code":""}]
